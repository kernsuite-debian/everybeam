Description: These header files are missing from upstream tarball

--- everybeam-0.1.2.orig/CMakeLists.txt
+++ everybeam-0.1.2/CMakeLists.txt
@@ -51,7 +51,7 @@ endif()
 
 # Include aocommon/eigen3/pybind11 headers
 include_directories("${CMAKE_SOURCE_DIR}/external/aocommon/include/")
-include_directories("${CMAKE_SOURCE_DIR}/external/eigen/")
+include_directories("/us
 add_subdirectory("${CMAKE_SOURCE_DIR}/external/pybind11")
 include_directories(${pybind11_INCLUDE_DIR})
 
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/banddata.h
@@ -0,0 +1,386 @@
+#ifndef BANDDATA_H
+#define BANDDATA_H
+
+#include <stdexcept>
+
+#include <casacore/ms/MeasurementSets/MeasurementSet.h>
+
+#include <casacore/tables/Tables/ArrayColumn.h>
+#include <casacore/tables/Tables/ScalarColumn.h>
+
+namespace aocommon {
+
+/** Global function that returns the speed of light in meters per second. */
+constexpr static long double c() { return 299792458.0L; }
+
+/** Holds the meta data of a channel. */
+class ChannelInfo {
+ public:
+  /** Construct a channel.
+   * @param frequency Channel frequency in Hz.
+   * @param width Channel width in Hz.
+   */
+  constexpr ChannelInfo(double frequency, double width)
+      : _frequency(frequency), _width(width) {}
+
+  /** Whether the frequency of the lhs is less than that of the rhs.
+   * @param rhs ChannelInfo to compare with.
+   * @returns lhs.Frequency() < rhs.Frequency()
+   */
+  constexpr bool operator<(const ChannelInfo& rhs) const {
+    return _frequency < rhs._frequency;
+  }
+
+  /** Whether the frequency of the lhs is greater than that of the rhs.
+   * @param rhs ChannelInfo to compare with.
+   * @returns lhs.Frequency() > rhs.Frequency()
+   */
+  constexpr bool operator>(const ChannelInfo& rhs) const {
+    return _frequency > rhs._frequency;
+  }
+
+  /** Whether the frequencies of lhs and rhs are the same. The channel width is
+   * ignored.
+   * @param rhs ChannelInfo to compare with
+   * @returns lhs.Frequency() == rhs.Frequency()
+   */
+  constexpr bool operator==(const ChannelInfo& rhs) const {
+    return _frequency == rhs._frequency;
+  }
+
+  /** Frequency of channel in Hz. */
+  constexpr double Frequency() const { return _frequency; }
+  /** Width of channel in Hz. */
+  constexpr double Width() const { return _width; }
+
+ private:
+  double _frequency, _width;
+};
+
+/**
+ * Contains information about a single band ("spectral window").
+ * A band consists of a sequence of contiguous channels.
+ */
+class BandData {
+ public:
+  /** Reverse iterator of frequencies */
+  typedef std::reverse_iterator<double*> reverse_iterator;
+  /** Constant reverse iterator of frequencies. */
+  typedef std::reverse_iterator<const double*> const_reverse_iterator;
+
+  /**
+   * Construct an empty instance.
+   */
+  BandData() : _channelCount(0), _channelFrequencies(), _frequencyStep(0.0) {}
+
+  /**
+   * Construct an instance from a spectral window table. The spectral window
+   * table can only have a single entry, otherwise an exception is thrown.
+   * @param spwTable The CASA Measurement Set spectral window table.
+   */
+  explicit BandData(const casacore::MSSpectralWindow& spwTable) {
+    if (spwTable.nrow() != 1)
+      throw std::runtime_error("Set should have exactly one spectral window");
+
+    initFromTable(spwTable, 0);
+  }
+
+  /**
+   * Construct an instance from a specified entry of a spectral window table.
+   * @param spwTable The CASA Measurement Set spectral window table.
+   * @param bandIndex The entry index of the spectral window table.
+   */
+  BandData(const casacore::MSSpectralWindow& spwTable, size_t bandIndex) {
+    initFromTable(spwTable, bandIndex);
+  }
+
+  /**
+   * Copy constructor.
+   * @param source Copied to the new banddata.
+   */
+  BandData(const BandData& source)
+      : _channelCount(source._channelCount),
+        _frequencyStep(source._frequencyStep) {
+    _channelFrequencies.reset(new double[_channelCount]);
+    for (size_t index = 0; index != _channelCount; ++index) {
+      _channelFrequencies[index] = source._channelFrequencies[index];
+    }
+  }
+
+  BandData(BandData&& source) noexcept
+      : _channelCount(source._channelCount),
+        _channelFrequencies(std::move(source._channelFrequencies)),
+        _frequencyStep(source._frequencyStep) {
+    source._channelCount = 0;
+    source._frequencyStep = 0.0;
+  }
+
+  /**
+   * Construct a new instance from a part of another band.
+   * @param source Instance that is partially copied.
+   * @param startChannel Start of range of channels that are copied.
+   * @param endChannel End of range, exclusive.
+   */
+  BandData(const BandData& source, size_t startChannel, size_t endChannel)
+      : _channelCount(endChannel - startChannel),
+        _frequencyStep(source._frequencyStep) {
+    if (_channelCount == 0) throw std::runtime_error("No channels in set");
+    if (endChannel < startChannel)
+      throw std::runtime_error("Invalid band specification");
+    _channelFrequencies.reset(new double[_channelCount]);
+
+    for (size_t index = 0; index != _channelCount; ++index) {
+      _channelFrequencies[index] =
+          source._channelFrequencies[index + startChannel];
+    }
+  }
+
+  /**
+   * Construct a banddata from an array with channel infos.
+   */
+  BandData(const std::vector<ChannelInfo>& channels) {
+    initFromArray(channels);
+  }
+
+  /** Copy assignment operator */
+  BandData operator=(const BandData& source) {
+    _channelCount = source._channelCount;
+    _frequencyStep = source._frequencyStep;
+    if (_channelCount != 0) {
+      _channelFrequencies.reset(new double[_channelCount]);
+      for (size_t index = 0; index != _channelCount; ++index) {
+        _channelFrequencies[index] = source._channelFrequencies[index];
+      }
+    } else {
+      _channelFrequencies = nullptr;
+    }
+    return *this;
+  }
+
+  /** Move assignment operator */
+  BandData operator=(BandData&& source) {
+    _channelCount = source._channelCount;
+    _frequencyStep = source._frequencyStep;
+    _channelFrequencies = std::move(source._channelFrequencies);
+    source._channelCount = 0;
+    source._frequencyStep = 0.0;
+    return *this;
+  }
+
+  /** Iterator over frequencies, pointing to first channel */
+  double* begin() { return _channelFrequencies.get(); }
+  /** Iterator over frequencies, pointing past last channel */
+  double* end() { return _channelFrequencies.get() + _channelCount; }
+  /** Constant iterator over frequencies, pointing to first channel */
+  const double* begin() const { return _channelFrequencies.get(); }
+  /** Constant iterator over frequencies, pointing to last channel */
+  const double* end() const {
+    return _channelFrequencies.get() + _channelCount;
+  }
+
+  /** Reverse iterator over frequencies, pointing to last channel */
+  std::reverse_iterator<double*> rbegin() {
+    return std::reverse_iterator<double*>(end());
+  }
+
+  /** Reverse iterator over frequencies, pointing past first channel */
+  std::reverse_iterator<double*> rend() {
+    return std::reverse_iterator<double*>(begin());
+  }
+
+  /** Constant reverse iterator over frequencies, pointing to last channel */
+  std::reverse_iterator<const double*> rbegin() const {
+    return std::reverse_iterator<const double*>(end());
+  }
+
+  /** Constant reverse iterator over frequencies, pointing past first channel */
+  std::reverse_iterator<const double*> rend() const {
+    return std::reverse_iterator<const double*>(begin());
+  }
+
+  /**
+   * Assign new frequencies to this instance.
+   * @param channelCount Number of channels.
+   * @param frequencies Array of @p channelCount doubles containing the channel
+   * frequencies.
+   */
+  void Set(size_t channelCount, const double* frequencies) {
+    _channelCount = channelCount;
+    _channelFrequencies.reset(new double[channelCount]);
+    std::copy(frequencies, frequencies + channelCount,
+              _channelFrequencies.get());
+  }
+
+  /** Retrieve number of channels in this band.
+   * @returns Number of channels.
+   */
+  size_t ChannelCount() const { return _channelCount; }
+
+  /** Get the frequency in Hz of a specified channel.
+   * @param channelIndex Zero-indexed channel index.
+   */
+  double ChannelFrequency(size_t channelIndex) const {
+    return _channelFrequencies[channelIndex];
+  }
+
+  /** Get the channelwidth in Hz of a specified channel.
+   * @param channelIndex Zero-indexed channel index.
+   */
+  double ChannelWidth(size_t /*channelIndex*/) const { return _frequencyStep; }
+
+  /** Get information of a specified channel.
+   * @param channelIndex Zero-indexed channel index.
+   */
+  ChannelInfo Channel(size_t channelIndex) const {
+    return ChannelInfo(_channelFrequencies[channelIndex], _frequencyStep);
+  }
+
+  /** Get the wavelength in m of a specified channel.
+   * @param channelIndex Zero-indexed channel index.
+   */
+  double ChannelWavelength(size_t channelIndex) const {
+    return c() / _channelFrequencies[channelIndex];
+  }
+
+  /**
+   * Get the frequency of the last channel.
+   * In case the frequencies are stored in reverse channel order, the frequency
+   * of the first channel is returned.
+   * @returns Highest frequency.
+   */
+  double HighestFrequency() const {
+    return _channelCount == 0 ? 0
+                              : lastChannel() > firstChannel() ? lastChannel()
+                                                               : firstChannel();
+  }
+
+  /**
+   * Get the frequency of the first channel.
+   * In case the frequencies are stored in reverse channel order, the frequency
+   * of the last channel is returned.
+   * @returns Lowest frequency.
+   */
+  double LowestFrequency() const {
+    return _channelCount == 0
+               ? 0
+               : (firstChannel() < lastChannel() ? firstChannel()
+                                                 : lastChannel());
+  }
+
+  /** Get the centre frequency.
+   * @returns 0.5 * (HighestFrequency + LowestFrequency)
+   */
+  double CentreFrequency() const {
+    return (HighestFrequency() + LowestFrequency()) * 0.5;
+  }
+
+  /** Convert a frequency to a wavelength.
+   * @param frequencyHz Frequency in Hz.
+   * @returns Wavelength in m.
+   */
+  static double FrequencyToLambda(double frequencyHz) {
+    return c() / frequencyHz;
+  }
+
+  /** Get the wavelength of the central channel.
+   * @returns Central channel wavelength.
+   */
+  double CentreWavelength() const {
+    return c() / ((HighestFrequency() + LowestFrequency()) * 0.5);
+  }
+
+  /** Get the distance between channels in Hz.
+   * @returns Distance between channels.
+   */
+  double FrequencyStep() const { return _frequencyStep; }
+
+  /** Get the wavelength of the first channel.
+   * @returns longest wavelength. */
+  double LongestWavelength() const {
+    return _channelCount == 0 ? 0 : c() / LowestFrequency();
+  }
+
+  /**
+   * Get the wavelength of the last channel.
+   * @returns smallest wavelength.
+   */
+  double SmallestWavelength() const {
+    return _channelCount == 0 ? 0 : c() / HighestFrequency();
+  }
+
+  /** Get the start of the frequency range covered by this band.
+   * @returns Start of the band in Hz.
+   */
+  double BandStart() const { return LowestFrequency() - FrequencyStep() * 0.5; }
+  /** Get the end of the frequency range covered by this band.
+   * @returns End of the band in Hz. */
+  double BandEnd() const { return HighestFrequency() + FrequencyStep() * 0.5; }
+
+  /** Get the total bandwidth covered by this band.
+   * @returns Bandwidth in Hz. */
+  double Bandwidth() const {
+    return HighestFrequency() - LowestFrequency() + FrequencyStep();
+  }
+
+ private:
+  void initFromTable(const casacore::MSSpectralWindow& spwTable,
+                     size_t bandIndex) {
+    casacore::ROScalarColumn<int> numChanCol(
+        spwTable, casacore::MSSpectralWindow::columnName(
+                      casacore::MSSpectralWindowEnums::NUM_CHAN));
+    int temp;
+    numChanCol.get(bandIndex, temp);
+    _channelCount = temp;
+    if (_channelCount == 0) throw std::runtime_error("No channels in set");
+
+    casacore::ROArrayColumn<double> chanFreqCol(
+        spwTable, casacore::MSSpectralWindow::columnName(
+                      casacore::MSSpectralWindowEnums::CHAN_FREQ));
+    casacore::ROArrayColumn<double> chanWidthCol(
+        spwTable, casacore::MSSpectralWindow::columnName(
+                      casacore::MSSpectralWindowEnums::CHAN_WIDTH));
+    casacore::Array<double> channelFrequencies, channelWidths;
+    chanFreqCol.get(bandIndex, channelFrequencies, true);
+    chanWidthCol.get(bandIndex, channelWidths, true);
+
+    _channelFrequencies.reset(new double[_channelCount]);
+    size_t index = 0;
+    for (casacore::Array<double>::const_iterator i = channelFrequencies.begin();
+         i != channelFrequencies.end(); ++i) {
+      _channelFrequencies[index] = *i;
+      ++index;
+    }
+    _frequencyStep = 0.0;
+    index = 0;
+    for (casacore::Array<double>::const_iterator i = channelWidths.begin();
+         i != channelWidths.end(); ++i) {
+      _frequencyStep += *i;
+      ++index;
+    }
+    _frequencyStep /= double(index);
+  }
+
+  void initFromArray(const std::vector<ChannelInfo>& channels) {
+    _channelCount = channels.size();
+    _channelFrequencies.reset(new double[_channelCount]);
+    size_t index = 0;
+    _frequencyStep = 0.0;
+    for (const ChannelInfo& channel : channels) {
+      _channelFrequencies[index] = channel.Frequency();
+      _frequencyStep += channel.Width();
+      ++index;
+    }
+    _frequencyStep /= double(index);
+  }
+
+  double firstChannel() const { return _channelFrequencies[0]; }
+  double lastChannel() const { return _channelFrequencies[_channelCount - 1]; }
+
+  size_t _channelCount;
+  std::unique_ptr<double[]> _channelFrequencies;
+  double _frequencyStep;
+};
+
+}  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/barrier.h
@@ -0,0 +1,75 @@
+#ifndef BARRIER_H
+#define BARRIER_H
+
+#include <condition_variable>
+#include <functional>
+#include <mutex>
+
+namespace aocommon {
+
+/**
+ * This class is unfortunately necessary because boost::barrier had a
+ * bug in completion functions, and std::barrier is still experimental.
+ */
+class Barrier {
+ public:
+  /**
+   * Construct barrier for n threads without a completion function.
+   * @param n Number of threads to wait for
+   * @param completionFunction void function that is called when all threads
+   * have arrived, just before the threads are released.
+   */
+  Barrier(size_t n)
+      : _n(n), _count(_n), _cycle(0), _completionFunction(&Barrier::nop) {}
+
+  /**
+   * Construct barrier for n threads with the given completion function.
+   * @param n Number of threads to wait for
+   * @param completionFunction void function that is called when all threads
+   * have arrived, just before the threads are released.
+   */
+  Barrier(size_t n, std::function<void()> completionFunction)
+      : _n(n), _count(_n), _cycle(0), _completionFunction(completionFunction) {}
+
+  /**
+   * @brief Move constructor
+   *
+   * count could be checked for != _n to assert no threads
+   * are waiting, but I leave this the responsibility of the caller.
+   */
+  Barrier& operator=(Barrier&& rhs) {
+    _n = rhs._n;
+    _count = _n;
+    _cycle = 0;
+    _completionFunction = rhs._completionFunction;
+    return *this;
+  }
+
+  /**
+   * Wait until all threads are waiting for the barrier.
+   */
+  void wait() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    --_count;
+    if (_count == 0) {
+      ++_cycle;
+      _count = _n;
+      _completionFunction();
+      _condition.notify_all();
+    } else {
+      size_t cycle = _cycle;
+      while (cycle == _cycle) _condition.wait(lock);
+    }
+  }
+
+ private:
+  static void nop() {}
+
+  std::mutex _mutex;
+  std::condition_variable _condition;
+  size_t _n, _count, _cycle;
+  std::function<void()> _completionFunction;
+};
+}  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/cloned_ptr.h
@@ -0,0 +1,53 @@
+#ifndef CLONED_PTR_H
+#define CLONED_PTR_H
+
+#include <cstddef>
+#include <memory>
+
+namespace aocommon {
+
+template <typename T>
+class cloned_ptr {
+ public:
+  cloned_ptr() noexcept {}
+  cloned_ptr(std::nullptr_t) noexcept {}
+  cloned_ptr(T *object) noexcept : _ptr(object) {}
+  cloned_ptr(const cloned_ptr<T> &other)
+      : _ptr(other._ptr == nullptr ? nullptr : new T(*other._ptr)) {}
+  cloned_ptr(cloned_ptr<T> &&other) noexcept : _ptr(std::move(other._ptr)) {}
+
+  cloned_ptr<T> &operator=(std::nullptr_t) noexcept { _ptr.reset(); }
+  cloned_ptr<T> &operator=(const cloned_ptr<T> &other) {
+    _ptr.reset(other._ptr == nullptr ? nullptr : new T(*other._ptr));
+  }
+  cloned_ptr<T> &operator=(cloned_ptr<T> &&other) noexcept {
+    _ptr = std::move(other._ptr);
+  }
+  void reset() noexcept { _ptr.reset(); }
+  void reset(T *object) noexcept { _ptr.reset(object); }
+
+  T &operator*() const noexcept { return *_ptr; }
+  T *operator->() const noexcept { return _ptr.get(); }
+  T *get() const { return _ptr.get(); }
+
+  bool operator==(std::nullptr_t) const noexcept { return _ptr == nullptr; }
+  bool operator==(const std::unique_ptr<T> &rhs) const noexcept {
+    return _ptr == rhs;
+  }
+  bool operator==(const cloned_ptr<T> &rhs) const noexcept {
+    return _ptr == rhs._ptr;
+  }
+  void swap(cloned_ptr<T> &other) noexcept { std::swap(_ptr, other._ptr); }
+
+ private:
+  std::unique_ptr<T> _ptr;
+};
+
+template <typename T>
+void swap(cloned_ptr<T> &left, cloned_ptr<T> &right) {
+  left.swap(right);
+}
+
+}  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/fits/fitsbase.h
@@ -0,0 +1,67 @@
+#ifndef FITS_IO_CHECKER_H
+#define FITS_IO_CHECKER_H
+
+#include <fitsio.h>
+
+#include <sstream>
+#include <stdexcept>
+#include <string>
+
+namespace aocommon {
+
+/// Base class for reading and writing fits files.
+/// Requires the fitsio library.
+class FitsBase {
+ protected:
+  static void checkStatus(int status, const std::string& filename) {
+    if (status) {
+      /* fits_get_errstatus returns at most 30 characters */
+      char err_text[31];
+      fits_get_errstatus(status, err_text);
+      char err_msg[81];
+      std::stringstream errMsg;
+      errMsg << "CFITSIO reported error when performing IO on file '"
+             << filename << "':" << err_text << " (";
+      while (fits_read_errmsg(err_msg)) errMsg << err_msg;
+      errMsg << ')';
+      throw std::runtime_error(errMsg.str());
+    }
+  }
+  static void checkStatus(int status, const std::string& filename,
+                          const std::string& operation) {
+    if (status) {
+      /* fits_get_errstatus returns at most 30 characters */
+      char err_text[31];
+      fits_get_errstatus(status, err_text);
+      char err_msg[81];
+      std::stringstream errMsg;
+      errMsg << "During operation " << operation
+             << ", CFITSIO reported error when performing IO on file '"
+             << filename << "': " << err_text << " (";
+      while (fits_read_errmsg(err_msg)) errMsg << err_msg;
+      errMsg << ')';
+      throw std::runtime_error(errMsg.str());
+    }
+  }
+
+ public:
+  enum Unit { JanskyPerBeam, JanskyPerPixel, Jansky, Kelvin, MilliKelvin };
+  static const char* UnitName(Unit unit) {
+    switch (unit) {
+      case JanskyPerBeam:
+        return "Jansky/beam";
+      case JanskyPerPixel:
+        return "Jansky/pixel";
+      case Jansky:
+        return "Jansky";
+      case Kelvin:
+        return "Kelvin";
+      case MilliKelvin:
+        return "Milli-Kelvin";
+    }
+    return "";
+  }
+};
+}  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/fits/fitsreader.h
@@ -0,0 +1,485 @@
+#ifndef FITSREADER_H
+#define FITSREADER_H
+
+#include <string>
+#include <vector>
+#include <stdexcept>
+#include <sstream>
+#include <cmath>
+
+#include <fitsio.h>
+
+#include "fitsbase.h"
+#include "../polarization.h"
+
+#include <casacore/fits/FITS/FITSDateUtil.h>
+#include <casacore/casa/Quanta/MVTime.h>
+#include <casacore/measures/Measures/MeasConvert.h>
+
+namespace aocommon {
+
+/// Requires the fitsio library.
+class FitsReader : public FitsBase {
+ public:
+  explicit FitsReader(const std::string& filename)
+      : FitsReader(filename, true, false) {}
+  explicit FitsReader(const std::string& filename, bool checkCType,
+                      bool allowMultipleImages = false)
+      : _meta(filename, checkCType, allowMultipleImages) {
+    initialize();
+  }
+  FitsReader(const FitsReader& source)
+      : _fitsPtr(nullptr), _meta(source._meta) {
+    int status = 0;
+    fits_open_file(&_fitsPtr, _meta.filename.c_str(), READONLY, &status);
+    checkStatus(status, _meta.filename);
+
+    // Move to first HDU
+    int hduType;
+    fits_movabs_hdu(_fitsPtr, 1, &hduType, &status);
+    checkStatus(status, _meta.filename);
+    if (hduType != IMAGE_HDU)
+      throw std::runtime_error("First HDU is not an image");
+  }
+  FitsReader(FitsReader&& source)
+      : _fitsPtr(source._fitsPtr), _meta(std::move(source._meta)) {
+    source._fitsPtr = nullptr;
+  }
+  ~FitsReader() {
+    if (_fitsPtr != nullptr) {
+      int status = 0;
+      fits_close_file(_fitsPtr, &status);
+    }
+  }
+
+  FitsReader& operator=(const FitsReader& rhs) {
+    if (_fitsPtr != nullptr) {
+      int status = 0;
+      fits_close_file(_fitsPtr, &status);
+      checkStatus(status, _meta.filename);
+    }
+
+    if (rhs._fitsPtr != nullptr) {
+      int status = 0;
+      fits_open_file(&_fitsPtr, _meta.filename.c_str(), READONLY, &status);
+      checkStatus(status, _meta.filename);
+
+      // Move to first HDU
+      int hduType;
+      fits_movabs_hdu(_fitsPtr, 1, &hduType, &status);
+      checkStatus(status, _meta.filename);
+      if (hduType != IMAGE_HDU)
+        throw std::runtime_error("First HDU is not an image");
+    }
+
+    return *this;
+  }
+  FitsReader& operator=(FitsReader&& rhs) {
+    if (_fitsPtr != nullptr) {
+      int status = 0;
+      fits_close_file(_fitsPtr, &status);
+      checkStatus(status, _meta.filename);
+    }
+    _meta = std::move(rhs._meta);
+    _fitsPtr = rhs._fitsPtr;
+    rhs._fitsPtr = nullptr;
+
+    return *this;
+  }
+
+  // template void ReadIndex(float* image, size_t index);
+  // template void ReadIndex(double* image, size_t index);
+
+  template <typename NumType>
+  void ReadIndex(NumType* image, size_t index) {
+    int status = 0;
+    int naxis = 0;
+    fits_get_img_dim(_fitsPtr, &naxis, &status);
+    checkStatus(status, _meta.filename);
+    std::vector<long> firstPixel(naxis);
+    for (int i = 0; i != naxis; ++i) firstPixel[i] = 1;
+    if (naxis > 2) firstPixel[2] = index + 1;
+
+    if (sizeof(NumType) == 8)
+      fits_read_pix(_fitsPtr, TDOUBLE, &firstPixel[0],
+                    _meta.imgWidth * _meta.imgHeight, 0, image, 0, &status);
+    else if (sizeof(NumType) == 4)
+      fits_read_pix(_fitsPtr, TFLOAT, &firstPixel[0],
+                    _meta.imgWidth * _meta.imgHeight, 0, image, 0, &status);
+    else
+      throw std::runtime_error("sizeof(NumType)!=8 || 4 not implemented");
+    checkStatus(status, _meta.filename);
+  }
+
+  template <typename NumType>
+  void Read(NumType* image) {
+    ReadIndex(image, 0);
+  }
+
+  size_t ImageWidth() const { return _meta.imgWidth; }
+  size_t ImageHeight() const { return _meta.imgHeight; }
+
+  double PhaseCentreRA() const { return _meta.phaseCentreRA; }
+  double PhaseCentreDec() const { return _meta.phaseCentreDec; }
+
+  double PixelSizeX() const { return _meta.pixelSizeX; }
+  double PixelSizeY() const { return _meta.pixelSizeY; }
+
+  double PhaseCentreDL() const { return _meta.phaseCentreDL; }
+  double PhaseCentreDM() const { return _meta.phaseCentreDM; }
+
+  double Frequency() const { return _meta.frequency; }
+  double Bandwidth() const { return _meta.bandwidth; }
+
+  double DateObs() const { return _meta.dateObs; }
+  aocommon::PolarizationEnum Polarization() const { return _meta.polarization; }
+
+  FitsBase::Unit Unit() const { return _meta.unit; }
+
+  bool HasBeam() const { return _meta.hasBeam; }
+  double BeamMajorAxisRad() const { return _meta.beamMajorAxisRad; }
+  double BeamMinorAxisRad() const { return _meta.beamMinorAxisRad; }
+  double BeamPositionAngle() const { return _meta.beamPositionAngle; }
+
+  const std::string& TelescopeName() const { return _meta.telescopeName; }
+  const std::string& Observer() const { return _meta.observer; }
+  const std::string& ObjectName() const { return _meta.objectName; }
+
+  const std::string& Origin() const { return _meta.origin; }
+  const std::string& OriginComment() const { return _meta.originComment; }
+
+  const std::vector<std::string>& History() const { return _meta.history; }
+
+  bool ReadDoubleKeyIfExists(const char* key, double& dest) {
+    int status = 0;
+    double doubleValue;
+    fits_read_key(_fitsPtr, TDOUBLE, key, &doubleValue, 0, &status);
+    if (status == 0) dest = doubleValue;
+    return status == 0;
+  }
+  bool ReadStringKeyIfExists(const char* key, std::string& dest) {
+    std::string c;
+    return ReadStringKeyIfExists(key, dest, c);
+  }
+  bool ReadStringKeyIfExists(const char* key, std::string& value,
+                             std::string& comment) {
+    int status = 0;
+    char valueStr[256], commentStr[256];
+    fits_read_key(_fitsPtr, TSTRING, key, valueStr, commentStr, &status);
+    if (status == 0) {
+      value = valueStr;
+      comment = commentStr;
+    }
+    return status == 0;
+  }
+  bool ReadFloatKeyIfExists(const char* key, float& dest) {
+    int status = 0;
+    float floatValue;
+    fits_read_key(_fitsPtr, TFLOAT, key, &floatValue, 0, &status);
+    if (status == 0) dest = floatValue;
+    return status == 0;
+  }
+
+  static double ParseFitsDateToMJD(const char* valueStr) {
+    casacore::MVTime time;
+    casacore::MEpoch::Types systypes;
+    bool parseSuccess =
+        casacore::FITSDateUtil::fromFITS(time, systypes, valueStr, "UTC");
+    if (!parseSuccess)
+      throw std::runtime_error(std::string("Could not parse FITS date: ") +
+                               valueStr);
+    casacore::MEpoch epoch(time.get(), systypes);
+    return epoch.getValue().get();
+  }
+
+  const std::string& Filename() const { return _meta.filename; }
+
+  fitsfile* FitsHandle() const { return _fitsPtr; }
+
+  size_t NMatrixElements() const { return _meta.nMatrixElements; }
+  size_t NFrequencies() const { return _meta.nFrequencies; }
+  size_t NAntennas() const { return _meta.nAntennas; }
+  size_t NTimesteps() const { return _meta.nTimesteps; }
+
+  double TimeDimensionStart() const { return _meta.timeDimensionStart; }
+  double TimeDimensionIncr() const { return _meta.timeDimensionIncr; }
+
+  double FrequencyDimensionStart() const { return _meta.frequency; }
+  double FrequencyDimensionIncr() const { return _meta.bandwidth; }
+
+  double ReadDoubleKey(const char* key) {
+    int status = 0;
+    double value;
+    fits_read_key(_fitsPtr, TDOUBLE, key, &value, 0, &status);
+    checkStatus(status, _meta.filename, std::string("Read float key ") + key);
+    return value;
+  }
+
+ private:
+  std::string readStringKey(const char* key) {
+    int status = 0;
+    char keyStr[256];
+    fits_read_key(_fitsPtr, TSTRING, key, keyStr, 0, &status);
+    checkStatus(status, _meta.filename, std::string("Read string key ") + key);
+    return std::string(keyStr);
+  }
+  void readHistory() {
+    int status = 0;
+    int npos, moreKeys;
+    fits_get_hdrspace(_fitsPtr, &npos, &moreKeys, &status);
+    checkStatus(status, _meta.filename);
+    char keyCard[256];
+    for (int pos = 1; pos <= npos; ++pos) {
+      fits_read_record(_fitsPtr, pos, keyCard, &status);
+      keyCard[7] = 0;
+      if (std::string("HISTORY") == keyCard) {
+        _meta.history.push_back(&keyCard[8]);
+      }
+    }
+  }
+  bool readDateKeyIfExists(const char* key, double& dest) {
+    int status = 0;
+    char keyStr[256];
+    fits_read_key(_fitsPtr, TSTRING, key, keyStr, 0, &status);
+    if (status == 0) {
+      dest = FitsReader::ParseFitsDateToMJD(keyStr);
+      return true;
+    } else
+      return false;
+  }
+
+  void initialize() {
+    _meta.nMatrixElements = 1;
+    _meta.nFrequencies = 1;
+    _meta.nAntennas = 1;
+    _meta.nTimesteps = 1;
+    _meta.phaseCentreRA = 0.0;
+    _meta.pixelSizeX = 0.0;
+    _meta.phaseCentreDec = 0.0;
+    _meta.pixelSizeY = 0.0;
+    _meta.dateObs = 0.0;
+    _meta.frequency = 0.0;
+    _meta.bandwidth = 0.0;
+    _meta.polarization = aocommon::Polarization::StokesI;
+    _meta.unit = JanskyPerBeam;
+
+    int status = 0;
+    fits_open_file(&_fitsPtr, _meta.filename.c_str(), READONLY, &status);
+    checkStatus(status, _meta.filename);
+
+    // Move to first HDU
+    int hduType;
+    fits_movabs_hdu(_fitsPtr, 1, &hduType, &status);
+    checkStatus(status, _meta.filename);
+    if (hduType != IMAGE_HDU)
+      throw std::runtime_error("First HDU is not an image");
+
+    int naxis = 0;
+    fits_get_img_dim(_fitsPtr, &naxis, &status);
+    checkStatus(status, _meta.filename);
+    if (naxis < 2) throw std::runtime_error("NAxis in image < 2");
+
+    std::vector<long> naxes(naxis);
+    fits_get_img_size(_fitsPtr, naxis, &naxes[0], &status);
+    checkStatus(status, _meta.filename);
+
+    _meta.imgWidth = naxes[0];
+    _meta.imgHeight = naxes[1];
+
+    // There are fits files that say naxis=2 but then still define
+    // the third and fourth axes, so we always continue reading
+    // at least 4 axes:
+    if (naxis < 4) {
+      naxis = 4;
+      while (naxes.size() < 4) naxes.emplace_back(1);
+    }
+
+    std::string tmp;
+    for (int i = 2; i != naxis; ++i) {
+      std::ostringstream name;
+      name << "CTYPE" << (i + 1);
+      if (ReadStringKeyIfExists(name.str().c_str(), tmp)) {
+        std::ostringstream crval, cdelt;
+        crval << "CRVAL" << (i + 1);
+        cdelt << "CDELT" << (i + 1);
+        if (tmp == "FREQ" || tmp == "VRAD" || tmp == "FREQ-OBS") {
+          _meta.nFrequencies = naxes[i];
+          _meta.frequency = ReadDoubleKey(crval.str().c_str());
+          _meta.bandwidth = ReadDoubleKey(cdelt.str().c_str());
+        } else if (tmp == "ANTENNA")
+          _meta.nAntennas = naxes[i];
+        else if (tmp == "TIME") {
+          _meta.nTimesteps = naxes[i];
+          _meta.timeDimensionStart = ReadDoubleKey(crval.str().c_str());
+          _meta.timeDimensionIncr = ReadDoubleKey(cdelt.str().c_str());
+        } else if (tmp == "STOKES") {
+          double val = ReadDoubleKey(crval.str().c_str());
+          switch (int(val)) {
+            default:
+              throw std::runtime_error(
+                  "Unknown polarization specified in fits file");
+            case 1:
+              _meta.polarization = aocommon::Polarization::StokesI;
+              break;
+            case 2:
+              _meta.polarization = aocommon::Polarization::StokesQ;
+              break;
+            case 3:
+              _meta.polarization = aocommon::Polarization::StokesU;
+              break;
+            case 4:
+              _meta.polarization = aocommon::Polarization::StokesV;
+              break;
+            case -1:
+              _meta.polarization = aocommon::Polarization::RR;
+              break;
+            case -2:
+              _meta.polarization = aocommon::Polarization::LL;
+              break;
+            case -3:
+              _meta.polarization = aocommon::Polarization::RL;
+              break;
+            case -4:
+              _meta.polarization = aocommon::Polarization::LR;
+              break;
+            case -5:
+              _meta.polarization = aocommon::Polarization::XX;
+              break;
+            case -6:
+              _meta.polarization = aocommon::Polarization::YY;
+              break;
+            case -7:
+              _meta.polarization = aocommon::Polarization::XY;
+              break;
+            case -8:
+              _meta.polarization = aocommon::Polarization::YX;
+              break;
+          }
+          if (naxes[i] != 1 && !_meta.allowMultipleImages)
+            throw std::runtime_error(
+                "Multiple polarizations given in fits file");
+        } else if (tmp == "MATRIX") {
+          _meta.nMatrixElements = naxes[i];
+        } else if (naxes[i] != 1)
+          throw std::runtime_error("Multiple images given in fits file");
+      }
+    }
+
+    if (_meta.nMatrixElements != 1 && !_meta.allowMultipleImages)
+      throw std::runtime_error("Multiple matrix elements given in fits file");
+    if (_meta.nFrequencies != 1 && !_meta.allowMultipleImages)
+      throw std::runtime_error("Multiple frequencies given in fits file");
+    if (_meta.nAntennas != 1 && !_meta.allowMultipleImages)
+      throw std::runtime_error("Multiple antennas given in fits file");
+    if (_meta.nTimesteps != 1 && !_meta.allowMultipleImages)
+      throw std::runtime_error("Multiple timesteps given in fits file");
+
+    double bScale = 1.0, bZero = 0.0, equinox = 2000.0;
+    ReadDoubleKeyIfExists("BSCALE", bScale);
+    ReadDoubleKeyIfExists("BZERO", bZero);
+    ReadDoubleKeyIfExists("EQUINOX", equinox);
+    if (bScale != 1.0) throw std::runtime_error("Invalid value for BSCALE");
+    if (bZero != 0.0) throw std::runtime_error("Invalid value for BZERO");
+    if (equinox != 2000.0)
+      throw std::runtime_error("Invalid value for EQUINOX: " +
+                               readStringKey("EQUINOX"));
+
+    if (ReadStringKeyIfExists("CTYPE1", tmp) && tmp != "RA---SIN" &&
+        _meta.checkCType)
+      throw std::runtime_error("Invalid value for CTYPE1");
+
+    ReadDoubleKeyIfExists("CRVAL1", _meta.phaseCentreRA);
+    _meta.phaseCentreRA *= M_PI / 180.0;
+    ReadDoubleKeyIfExists("CDELT1", _meta.pixelSizeX);
+    _meta.pixelSizeX *= -M_PI / 180.0;
+    if (ReadStringKeyIfExists("CUNIT1", tmp) && tmp != "deg" &&
+        _meta.checkCType)
+      throw std::runtime_error("Invalid value for CUNIT1");
+    double centrePixelX = 0.0;
+    if (ReadDoubleKeyIfExists("CRPIX1", centrePixelX))
+      _meta.phaseCentreDL =
+          (centrePixelX - ((_meta.imgWidth / 2.0) + 1.0)) * _meta.pixelSizeX;
+    else
+      _meta.phaseCentreDL = 0.0;
+
+    if (ReadStringKeyIfExists("CTYPE2", tmp) && tmp != "DEC--SIN" &&
+        _meta.checkCType)
+      throw std::runtime_error("Invalid value for CTYPE2");
+    ReadDoubleKeyIfExists("CRVAL2", _meta.phaseCentreDec);
+    _meta.phaseCentreDec *= M_PI / 180.0;
+    ReadDoubleKeyIfExists("CDELT2", _meta.pixelSizeY);
+    _meta.pixelSizeY *= M_PI / 180.0;
+    if (ReadStringKeyIfExists("CUNIT2", tmp) && tmp != "deg" &&
+        _meta.checkCType)
+      throw std::runtime_error("Invalid value for CUNIT2");
+    double centrePixelY = 0.0;
+    if (ReadDoubleKeyIfExists("CRPIX2", centrePixelY))
+      _meta.phaseCentreDM =
+          ((_meta.imgHeight / 2.0) + 1.0 - centrePixelY) * _meta.pixelSizeY;
+    else
+      _meta.phaseCentreDM = 0.0;
+
+    readDateKeyIfExists("DATE-OBS", _meta.dateObs);
+
+    double bMaj = 0.0, bMin = 0.0, bPa = 0.0;
+    if (ReadDoubleKeyIfExists("BMAJ", bMaj) &&
+        ReadDoubleKeyIfExists("BMIN", bMin) &&
+        ReadDoubleKeyIfExists("BPA", bPa)) {
+      _meta.hasBeam = true;
+      _meta.beamMajorAxisRad = bMaj * (M_PI / 180.0);
+      _meta.beamMinorAxisRad = bMin * (M_PI / 180.0);
+      _meta.beamPositionAngle = bPa * (M_PI / 180.0);
+    } else {
+      _meta.hasBeam = false;
+      _meta.beamMajorAxisRad = 0.0;
+      _meta.beamMinorAxisRad = 0.0;
+      _meta.beamPositionAngle = 0.0;
+    }
+
+    _meta.telescopeName = std::string();
+    ReadStringKeyIfExists("TELESCOP", _meta.telescopeName);
+    _meta.observer = std::string();
+    ReadStringKeyIfExists("OBSERVER", _meta.observer);
+    _meta.objectName = std::string();
+    ReadStringKeyIfExists("OBJECT", _meta.objectName);
+
+    _meta.origin = std::string();
+    _meta.originComment = std::string();
+    ReadStringKeyIfExists("ORIGIN", _meta.origin, _meta.originComment);
+
+    _meta.history.clear();
+    readHistory();
+  }
+
+  fitsfile* _fitsPtr;
+
+  struct MetaData {
+    MetaData(const std::string& filename_, bool checkCType_,
+             bool allowMultipleImages_)
+        : filename(filename_),
+          hasBeam(false),
+          checkCType(checkCType_),
+          allowMultipleImages(allowMultipleImages_) {}
+    std::string filename;
+    size_t imgWidth, imgHeight;
+    size_t nMatrixElements, nAntennas, nFrequencies, nTimesteps;
+    double phaseCentreRA, phaseCentreDec;
+    double pixelSizeX, pixelSizeY;
+    double phaseCentreDL, phaseCentreDM;
+    double frequency, bandwidth, dateObs;
+    bool hasBeam;
+    double beamMajorAxisRad, beamMinorAxisRad, beamPositionAngle;
+    double timeDimensionStart, timeDimensionIncr;
+
+    aocommon::PolarizationEnum polarization;
+    FitsBase::Unit unit;
+    std::string telescopeName, observer, objectName;
+    std::string origin, originComment;
+    std::vector<std::string> history;
+
+    bool checkCType, allowMultipleImages;
+  } _meta;
+};
+}  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/fits/fitswriter.h
@@ -0,0 +1,712 @@
+#ifndef FITSWRITER_H
+#define FITSWRITER_H
+
+#include <fitsio.h>
+
+#include <array>
+#include <string>
+#include <vector>
+#include <map>
+#include <cmath>
+
+#include "fitsbase.h"
+#include "fitsreader.h"
+#include "../polarization.h"
+#include "../uvector.h"
+
+namespace aocommon {
+
+/// Requires the fitsio library.
+class FitsWriter : public FitsBase {
+ public:
+  enum DimensionType {
+    FrequencyDimension,
+    PolarizationDimension,
+    AntennaDimension,
+    TimeDimension,
+    MatrixDimension
+  };
+
+  FitsWriter()
+      : _width(0),
+        _height(0),
+        _phaseCentreRA(0.0),
+        _phaseCentreDec(0.0),
+        _pixelSizeX(0.0),
+        _pixelSizeY(0.0),
+        _phaseCentreDL(0.0),
+        _phaseCentreDM(0.0),
+        _frequency(0.0),
+        _bandwidth(0.0),
+        _dateObs(0.0),
+        _hasBeam(false),
+        _beamMajorAxisRad(0.0),
+        _beamMinorAxisRad(0.0),
+        _beamPositionAngle(0.0),
+        _polarization(aocommon::Polarization::StokesI),
+        _unit(JanskyPerBeam),
+        _isUV(false),
+        _telescopeName(),
+        _observer(),
+        _objectName(),
+        _origin("AO/WSImager"),
+        _originComment("Imager written by Andre Offringa"),
+        _multiFPtr(nullptr) {}
+
+  explicit FitsWriter(const class FitsReader& reader)
+      : _width(0),
+        _height(0),
+        _phaseCentreRA(0.0),
+        _phaseCentreDec(0.0),
+        _pixelSizeX(0.0),
+        _pixelSizeY(0.0),
+        _phaseCentreDL(0.0),
+        _phaseCentreDM(0.0),
+        _frequency(0.0),
+        _bandwidth(0.0),
+        _dateObs(0.0),
+        _hasBeam(false),
+        _beamMajorAxisRad(0.0),
+        _beamMinorAxisRad(0.0),
+        _beamPositionAngle(0.0),
+        _polarization(aocommon::Polarization::StokesI),
+        _unit(JanskyPerBeam),
+        _isUV(false),
+        _telescopeName(),
+        _observer(),
+        _objectName(),
+        _origin("AO/WSImager"),
+        _originComment("Imager written by Andre Offringa"),
+        _multiFPtr(nullptr) {
+    SetMetadata(reader);
+  }
+
+  ~FitsWriter() {
+    if (_multiFPtr != nullptr) FinishMulti();
+  }
+
+  // template void Write<long double>(const std::string& filename,
+  //                                  const long double* image) const;
+  // template void Write<double>(const std::string& filename,
+  //                             const double* image) const;
+  // template void Write<float>(const std::string& filename,
+  //                            const float* image) const;
+
+  template <typename NumType>
+  void Write(const std::string& filename, const NumType* image) const {
+    fitsfile* fptr;
+
+    writeHeaders(fptr, filename);
+
+    long firstPixel[4] = {1, 1, 1, 1};
+    writeImage(fptr, filename, image, firstPixel);
+
+    int status = 0;
+    fits_close_file(fptr, &status);
+    checkStatus(status, filename);
+  }
+
+  void WriteMask(const std::string& filename, const bool* mask) const {
+    aocommon::UVector<float> maskAsImage(_width * _height);
+    for (size_t i = 0; i != _width * _height; ++i)
+      maskAsImage[i] = mask[i] ? 1.0 : 0.0;
+    Write(filename, maskAsImage.data());
+  }
+
+  void StartMulti(const std::string& filename) {
+    if (_multiFPtr != 0)
+      throw std::runtime_error(
+          "StartMulti() called twice without calling FinishMulti()");
+    _multiFilename = filename;
+    writeHeaders(_multiFPtr, _multiFilename, _extraDimensions);
+    _currentPixel.assign(_extraDimensions.size() + 2, 1);
+  }
+
+  template <typename NumType>
+  void AddToMulti(const NumType* image) {
+    if (_multiFPtr == 0)
+      throw std::runtime_error("AddToMulti() called before StartMulti()");
+    writeImage(_multiFPtr, _multiFilename, image, _currentPixel.data());
+    size_t index = 2;
+    _currentPixel[index]++;
+    while (index < _currentPixel.size() - 1 &&
+           _currentPixel[index] > long(_extraDimensions[index - 2].size)) {
+      _currentPixel[index] = 1;
+      ++index;
+      _currentPixel[index]++;
+    }
+  }
+
+  void FinishMulti() {
+    int status = 0;
+    fits_close_file(_multiFPtr, &status);
+    checkStatus(status, _multiFilename);
+    _multiFPtr = 0;
+  }
+
+  void SetBeamInfo(double widthRad) { SetBeamInfo(widthRad, widthRad, 0.0); }
+  void SetBeamInfo(double majorAxisRad, double minorAxisRad,
+                   double positionAngleRad) {
+    _hasBeam = true;
+    _beamMajorAxisRad = majorAxisRad;
+    _beamMinorAxisRad = minorAxisRad;
+    _beamPositionAngle = positionAngleRad;
+  }
+  void SetNoBeamInfo() {
+    _hasBeam = false;
+    _beamMajorAxisRad = 0.0;
+    _beamMinorAxisRad = 0.0;
+    _beamPositionAngle = 0.0;
+  }
+  void SetImageDimensions(size_t width, size_t height) {
+    _width = width;
+    _height = height;
+  }
+  void SetImageDimensions(size_t width, size_t height, double pixelSizeX,
+                          double pixelSizeY) {
+    _width = width;
+    _height = height;
+    _pixelSizeX = pixelSizeX;
+    _pixelSizeY = pixelSizeY;
+  }
+  void SetImageDimensions(size_t width, size_t height, double phaseCentreRA,
+                          double phaseCentreDec, double pixelSizeX,
+                          double pixelSizeY) {
+    _width = width;
+    _height = height;
+    _phaseCentreRA = phaseCentreRA;
+    _phaseCentreDec = phaseCentreDec;
+    _pixelSizeX = pixelSizeX;
+    _pixelSizeY = pixelSizeY;
+  }
+  void SetFrequency(double frequency, double bandwidth) {
+    _frequency = frequency;
+    _bandwidth = bandwidth;
+  }
+  void SetDate(double dateObs) { _dateObs = dateObs; }
+  void SetPolarization(aocommon::PolarizationEnum polarization) {
+    _polarization = polarization;
+  }
+  Unit GetUnit() const { return _unit; }
+  void SetUnit(Unit unit) { _unit = unit; }
+  void SetIsUV(bool isUV) { _isUV = isUV; }
+  void SetTelescopeName(const std::string& telescopeName) {
+    _telescopeName = telescopeName;
+  }
+  void SetObserver(const std::string& observer) { _observer = observer; }
+  void SetObjectName(const std::string& objectName) {
+    _objectName = objectName;
+  }
+  void SetOrigin(const std::string& origin, const std::string& comment) {
+    _origin = origin;
+    _originComment = comment;
+  }
+  void SetHistory(const std::vector<std::string>& history) {
+    _history = history;
+  }
+  void AddHistory(const std::string& historyLine) {
+    _history.push_back(historyLine);
+  }
+
+  void SetMetadata(const FitsReader& reader) {
+    _width = reader.ImageWidth();
+    _height = reader.ImageHeight();
+    _phaseCentreRA = reader.PhaseCentreRA();
+    _phaseCentreDec = reader.PhaseCentreDec();
+    _pixelSizeX = reader.PixelSizeX();
+    _pixelSizeY = reader.PixelSizeY();
+    _frequency = reader.Frequency();
+    _bandwidth = reader.Bandwidth();
+    _dateObs = reader.DateObs();
+    _polarization = reader.Polarization();
+    _hasBeam = reader.HasBeam();
+    if (_hasBeam) {
+      _beamMajorAxisRad = reader.BeamMajorAxisRad();
+      _beamMinorAxisRad = reader.BeamMinorAxisRad();
+      _beamPositionAngle = reader.BeamPositionAngle();
+    }
+    _phaseCentreDL = reader.PhaseCentreDL();
+    _phaseCentreDM = reader.PhaseCentreDM();
+    _telescopeName = reader.TelescopeName();
+    _observer = reader.Observer();
+    _objectName = reader.ObjectName();
+    _origin = reader.Origin();
+    _originComment = reader.OriginComment();
+    _history = reader.History();
+  }
+
+  double RA() const { return _phaseCentreRA; }
+  double Dec() const { return _phaseCentreDec; }
+  double Frequency() const { return _frequency; }
+  double Bandwidth() const { return _bandwidth; }
+  double BeamSizeMajorAxis() const { return _beamMajorAxisRad; }
+  double BeamSizeMinorAxis() const { return _beamMinorAxisRad; }
+  double BeamPositionAngle() const { return _beamPositionAngle; }
+
+  void SetExtraKeyword(const std::string& name, const std::string& value) {
+    if (_extraStringKeywords.count(name) != 0) _extraStringKeywords.erase(name);
+    _extraStringKeywords.insert(std::make_pair(name, value));
+  }
+  void SetExtraKeyword(const std::string& name, double value) {
+    if (_extraNumKeywords.count(name) != 0) _extraNumKeywords.erase(name);
+    _extraNumKeywords.insert(std::make_pair(name, value));
+  }
+  void RemoveExtraKeyword(const std::string& name) {
+    if (_extraNumKeywords.count(name) != 0) _extraNumKeywords.erase(name);
+    if (_extraStringKeywords.count(name) != 0) _extraStringKeywords.erase(name);
+  }
+  void SetExtraStringKeywords(
+      const std::map<std::string, std::string>& keywords) {
+    _extraStringKeywords = keywords;
+  }
+  void SetExtraNumKeywords(const std::map<std::string, double>& keywords) {
+    _extraNumKeywords = keywords;
+  }
+  void SetPhaseCentreShift(double dl, double dm) {
+    _phaseCentreDL = dl;
+    _phaseCentreDM = dm;
+  }
+  size_t Width() const { return _width; }
+  size_t Height() const { return _height; }
+  double PhaseCentreDL() const { return _phaseCentreDL; }
+  double PhaseCentreDM() const { return _phaseCentreDM; }
+
+  void CopyDoubleKeywordIfExists(FitsReader& reader, const char* keywordName) {
+    double v;
+    if (reader.ReadDoubleKeyIfExists(keywordName, v))
+      SetExtraKeyword(keywordName, v);
+  }
+
+  void CopyStringKeywordIfExists(FitsReader& reader, const char* keywordName) {
+    std::string v;
+    if (reader.ReadStringKeyIfExists(keywordName, v))
+      SetExtraKeyword(keywordName, v);
+  }
+
+  static void MJDToHMS(double mjd, int& hour, int& minutes, int& seconds,
+                       int& deciSec) {
+    // It might seem one can calculate each of these immediately
+    // without adjusting 'mjd', but this way circumvents some
+    // catastrophic rounding problems, where "0:59.9" might end up
+    // as "1:59.9".
+    deciSec = int(fmod(mjd * 36000.0 * 24.0, 10.0));
+    mjd -= double(deciSec) / (36000.0 * 24.0);
+
+    seconds = int(fmod(round(mjd * 3600.0 * 24.0), 60.0));
+    mjd -= double(seconds) / (3600.0 * 24.0);
+
+    minutes = int(fmod(round(mjd * 60.0 * 24.0), 60.0));
+    mjd -= double(minutes) / (60.0 * 24.0);
+
+    hour = int(fmod(round(mjd * 24.0), 24.0));
+  }
+
+  void AddExtraDimension(enum DimensionType type, size_t size) {
+    _extraDimensions.emplace_back(Dimension{type, size});
+  }
+  void SetTimeDirectionStart(double time) { _timeDirectionStart = time; }
+  void SetTimeDirectionInc(double dTime) { _timeDirectionInc = dTime; }
+
+ private:
+  struct Dimension {
+    DimensionType type;
+    size_t size;
+  };
+
+  template <typename T>
+  static T setNotFiniteToZero(T num) {
+    return std::isfinite(num) ? num : 0.0;
+  }
+  std::size_t _width, _height;
+  double _phaseCentreRA, _phaseCentreDec, _pixelSizeX, _pixelSizeY;
+  double _phaseCentreDL, _phaseCentreDM;
+  double _frequency, _bandwidth;
+  double _dateObs;
+  bool _hasBeam;
+  double _beamMajorAxisRad, _beamMinorAxisRad, _beamPositionAngle;
+  aocommon::PolarizationEnum _polarization;
+  Unit _unit;
+  bool _isUV;
+  std::string _telescopeName, _observer, _objectName;
+  std::string _origin, _originComment;
+  std::vector<std::string> _history;
+  std::vector<Dimension> _extraDimensions;
+  std::map<std::string, std::string> _extraStringKeywords;
+  std::map<std::string, double> _extraNumKeywords;
+  double _timeDirectionStart, _timeDirectionInc;
+
+  void julianDateToYMD(double jd, int& year, int& month, int& day) const {
+    int z = jd + 0.5;
+    int w = (z - 1867216.25) / 36524.25;
+    int x = w / 4;
+    int a = z + 1 + w - x;
+    int b = a + 1524;
+    int c = (b - 122.1) / 365.25;
+    int d = 365.25 * c;
+    int e = (b - d) / 30.6001;
+    int f = 30.6001 * e;
+    day = b - d - f;
+    while (e - 1 > 12) e -= 12;
+    month = e - 1;
+    year = c - 4715 - ((e - 1) > 2 ? 1 : 0);
+  }
+
+  void writeHeaders(fitsfile*& fptr, const std::string& filename) const {
+    if (_extraDimensions.empty()) {
+      std::vector<Dimension> dimensions(2);
+      dimensions[0].type = FrequencyDimension;
+      dimensions[0].size = 1;
+      dimensions[1].type = PolarizationDimension;
+      dimensions[1].size = 1;
+      writeHeaders(fptr, filename, dimensions);
+    } else {
+      writeHeaders(fptr, filename, _extraDimensions);
+    }
+  }
+
+  void writeHeaders(fitsfile*& fptr, const std::string& filename,
+                    const std::vector<Dimension>& extraDimensions) const {
+    int status = 0;
+    fits_create_file(&fptr, (std::string("!") + filename).c_str(), &status);
+    checkStatus(status, filename);
+
+    // append image HDU
+    int bitPixInt = FLOAT_IMG;
+    std::vector<long> naxes(2 + extraDimensions.size());
+    naxes[0] = _width;
+    naxes[1] = _height;
+    for (size_t i = 0; i != extraDimensions.size(); ++i)
+      naxes[i + 2] = extraDimensions[i].size;
+    fits_create_img(fptr, bitPixInt, naxes.size(), naxes.data(), &status);
+    checkStatus(status, filename);
+    double zero = 0, one = 1, equinox = 2000.0;
+    fits_write_key(fptr, TDOUBLE, "BSCALE", (void*)&one, "", &status);
+    checkStatus(status, filename);
+    fits_write_key(fptr, TDOUBLE, "BZERO", (void*)&zero, "", &status);
+    checkStatus(status, filename);
+
+    switch (_unit) {
+      default:
+      case JanskyPerBeam:
+        fits_write_key(fptr, TSTRING, "BUNIT", (void*)"JY/BEAM",
+                       "Units are in Jansky per beam", &status);
+        checkStatus(status, filename);
+        break;
+      case JanskyPerPixel:
+        fits_write_key(fptr, TSTRING, "BUNIT", (void*)"JY/PIXEL",
+                       "Units are in Jansky per pixel", &status);
+        checkStatus(status, filename);
+        break;
+      case Jansky:
+        fits_write_key(fptr, TSTRING, "BUNIT", (void*)"JY",
+                       "Units are in Jansky", &status);
+        checkStatus(status, filename);
+        break;
+      case Kelvin:
+        fits_write_key(fptr, TSTRING, "BUNIT", (void*)"K",
+                       "Units are in Kelvin", &status);
+        checkStatus(status, filename);
+        break;
+      case MilliKelvin:
+        fits_write_key(fptr, TSTRING, "BUNIT", (void*)"mK",
+                       "Units are in milli Kelvin", &status);
+        checkStatus(status, filename);
+        break;
+    }
+
+    if (_hasBeam) {
+      double majDeg = setNotFiniteToZero(_beamMajorAxisRad * 180.0 / M_PI),
+             minDeg = setNotFiniteToZero(_beamMinorAxisRad * 180.0 / M_PI),
+             posAngle = setNotFiniteToZero(_beamPositionAngle * 180.0 / M_PI);
+      fits_write_key(fptr, TDOUBLE, "BMAJ", (void*)&majDeg, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "BMIN", (void*)&minDeg, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "BPA", (void*)&posAngle, "", &status);
+      checkStatus(status, filename);
+    }
+
+    fits_write_key(fptr, TDOUBLE, "EQUINOX", (void*)&equinox, "J2000", &status);
+    checkStatus(status, filename);
+    fits_write_key(fptr, TSTRING, "BTYPE", (void*)"Intensity", "", &status);
+    checkStatus(status, filename);
+    if (!_telescopeName.empty()) {
+      fits_write_key(fptr, TSTRING, "TELESCOP", (void*)_telescopeName.c_str(),
+                     "", &status);
+      checkStatus(status, filename);
+    }
+    if (!_observer.empty()) {
+      fits_write_key(fptr, TSTRING, "OBSERVER", (void*)_observer.c_str(), "",
+                     &status);
+      checkStatus(status, filename);
+    }
+    if (!_objectName.empty()) {
+      fits_write_key(fptr, TSTRING, "OBJECT", (void*)_objectName.c_str(), "",
+                     &status);
+      checkStatus(status, filename);
+    }
+    fits_write_key(fptr, TSTRING, "ORIGIN", (void*)_origin.c_str(),
+                   _originComment.c_str(), &status);
+    checkStatus(status, filename);
+    double phaseCentreRADeg = (_phaseCentreRA / M_PI) * 180.0,
+           phaseCentreDecDeg = (_phaseCentreDec / M_PI) * 180.0;
+    double centrePixelX =
+               _pixelSizeX != 0.0
+                   ? ((_width / 2.0) + 1.0 + _phaseCentreDL / _pixelSizeX)
+                   : (_width / 2.0) + 1.0,
+           centrePixelY =
+               _pixelSizeY != 0.0
+                   ? ((_height / 2.0) + 1.0 - _phaseCentreDM / _pixelSizeY)
+                   : (_height / 2.0) + 1.0;
+    if (_isUV) {
+      double deltX, deltY;
+      if (_pixelSizeX == 0.0 || _pixelSizeY == 0.0) {
+        deltX = 1.0;
+        deltY = 1.0;
+      } else {
+        deltX = 1.0 / (_width * _pixelSizeX);
+        deltY = 1.0 / (_height * _pixelSizeY);
+      }
+      fits_write_key(fptr, TSTRING, "CTYPE1", (void*)"U---WAV",
+                     "U axis of UV plane", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRPIX1", (void*)&centrePixelX, "",
+                     &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRVAL1", (void*)&zero, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CDELT1", (void*)&deltX, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TSTRING, "CUNIT1", (void*)"lambda", "", &status);
+      checkStatus(status, filename);
+
+      fits_write_key(fptr, TSTRING, "CTYPE2", (void*)"V---WAV",
+                     "V axis of UV plane", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRPIX2", (void*)&centrePixelY, "",
+                     &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRVAL2", (void*)&zero, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CDELT2", (void*)&deltY, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TSTRING, "CUNIT2", (void*)"lambda", "", &status);
+      checkStatus(status, filename);
+    } else {
+      double stepXDeg = (-_pixelSizeX / M_PI) * 180.0,
+             stepYDeg = (_pixelSizeY / M_PI) * 180.0;
+      fits_write_key(fptr, TSTRING, "CTYPE1", (void*)"RA---SIN",
+                     "Right ascension angle cosine", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRPIX1", (void*)&centrePixelX, "",
+                     &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRVAL1", (void*)&phaseCentreRADeg, "",
+                     &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CDELT1", (void*)&stepXDeg, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TSTRING, "CUNIT1", (void*)"deg", "", &status);
+      checkStatus(status, filename);
+
+      fits_write_key(fptr, TSTRING, "CTYPE2", (void*)"DEC--SIN",
+                     "Declination angle cosine", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRPIX2", (void*)&centrePixelY, "",
+                     &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CRVAL2", (void*)&phaseCentreDecDeg, "",
+                     &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TDOUBLE, "CDELT2", (void*)&stepYDeg, "", &status);
+      checkStatus(status, filename);
+      fits_write_key(fptr, TSTRING, "CUNIT2", (void*)"deg", "", &status);
+      checkStatus(status, filename);
+    }
+
+    char ctypeDim[7] = "CTYPE?", crpixDim[7] = "CRPIX?", crvalDim[7] = "CRVAL?",
+         cdeltDim[7] = "CDELT?", cunitDim[7] = "CUNIT?";
+    for (size_t i = 0; i != extraDimensions.size(); ++i) {
+      ctypeDim[5] = (i + '3');
+      crpixDim[5] = (i + '3');
+      crvalDim[5] = (i + '3');
+      cdeltDim[5] = (i + '3');
+      cunitDim[5] = (i + '3');
+      switch (extraDimensions[i].type) {
+        case FrequencyDimension:
+          fits_write_key(fptr, TSTRING, ctypeDim, (void*)"FREQ",
+                         "Central frequency", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crpixDim, (void*)&one, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crvalDim, (void*)&_frequency, "",
+                         &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, cdeltDim, (void*)&_bandwidth, "",
+                         &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TSTRING, cunitDim, (void*)"Hz", "", &status);
+          checkStatus(status, filename);
+          break;
+        case PolarizationDimension: {
+          double pol;
+          switch (_polarization) {
+            case aocommon::Polarization::StokesI:
+              pol = 1.0;
+              break;
+            case aocommon::Polarization::StokesQ:
+              pol = 2.0;
+              break;
+            case aocommon::Polarization::StokesU:
+              pol = 3.0;
+              break;
+            case aocommon::Polarization::StokesV:
+              pol = 4.0;
+              break;
+            case aocommon::Polarization::RR:
+              pol = -1.0;
+              break;
+            case aocommon::Polarization::LL:
+              pol = -2.0;
+              break;
+            case aocommon::Polarization::RL:
+              pol = -3.0;
+              break;
+            case aocommon::Polarization::LR:
+              pol = -4.0;
+              break;
+            case aocommon::Polarization::XX:
+              pol = -5.0;
+              break;
+            case aocommon::Polarization::YY:
+              pol = -6.0;
+              break;  // yup, this is really the right value
+            case aocommon::Polarization::XY:
+              pol = -7.0;
+              break;
+            case aocommon::Polarization::YX:
+              pol = -8.0;
+              break;
+            case aocommon::Polarization::Instrumental:
+              throw std::runtime_error(
+                  "Incorrect polarization given to fits writer");
+          }
+          fits_write_key(fptr, TSTRING, ctypeDim, (void*)"STOKES", "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crpixDim, (void*)&one, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crvalDim, (void*)&pol, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, cdeltDim, (void*)&one, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TSTRING, cunitDim, (void*)"", "", &status);
+          checkStatus(status, filename);
+        } break;
+        case AntennaDimension:
+          fits_write_key(fptr, TSTRING, ctypeDim, (void*)"ANTENNA", "",
+                         &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crpixDim, (void*)&one, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crvalDim, (void*)&zero, "", &status);
+          checkStatus(status, filename);
+          break;
+        case TimeDimension:
+          fits_write_key(fptr, TSTRING, ctypeDim, (void*)"TIME", "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crpixDim, (void*)&one, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crvalDim, (void*)&_timeDirectionStart,
+                         "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, cdeltDim, (void*)&_timeDirectionInc, "",
+                         &status);
+          checkStatus(status, filename);
+          break;
+        case MatrixDimension:
+          fits_write_key(fptr, TSTRING, ctypeDim, (void*)"MATRIX", "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crpixDim, (void*)&one, "", &status);
+          checkStatus(status, filename);
+          fits_write_key(fptr, TDOUBLE, crvalDim, (void*)&zero, "", &status);
+          checkStatus(status, filename);
+          break;
+      }
+    }
+
+    // RESTFRQ ?
+    fits_write_key(fptr, TSTRING, "SPECSYS", (void*)"TOPOCENT", "", &status);
+    checkStatus(status, filename);
+
+    int year, month, day, hour, min, sec, deciSec;
+    julianDateToYMD(_dateObs + 2400000.5, year, month, day);
+    MJDToHMS(_dateObs, hour, min, sec, deciSec);
+    char dateStr[40];
+    std::sprintf(dateStr, "%d-%02d-%02dT%02d:%02d:%02d.%01d", year, month, day,
+                 hour, min, sec, deciSec);
+    fits_write_key(fptr, TSTRING, "DATE-OBS", (void*)dateStr, "", &status);
+    checkStatus(status, filename);
+
+    // Extra keywords
+    for (std::map<std::string, std::string>::const_iterator i =
+             _extraStringKeywords.begin();
+         i != _extraStringKeywords.end(); ++i) {
+      const char* name = i->first.c_str();
+      char* valueStr = const_cast<char*>(i->second.c_str());
+      fits_write_key(fptr, TSTRING, name, valueStr, "", &status);
+      checkStatus(status, filename);
+    }
+    for (std::map<std::string, double>::const_iterator i =
+             _extraNumKeywords.begin();
+         i != _extraNumKeywords.end(); ++i) {
+      const char* name = i->first.c_str();
+      double value = setNotFiniteToZero(i->second);
+      fits_write_key(fptr, TDOUBLE, name, (void*)&value, "", &status);
+      checkStatus(status, filename);
+    }
+
+    // History
+    std::ostringstream histStr;
+    for (std::vector<std::string>::const_iterator i = _history.begin();
+         i != _history.end(); ++i) {
+      fits_write_history(fptr, i->c_str(), &status);
+      checkStatus(status, filename);
+    }
+  }
+  void writeImage(fitsfile* fptr, const std::string& filename,
+                  const double* image, long* currentPixel) const {
+    double nullValue = std::numeric_limits<double>::max();
+    int status = 0;
+    fits_write_pixnull(fptr, TDOUBLE, currentPixel, _width * _height,
+                       const_cast<double*>(image), &nullValue, &status);
+    checkStatus(status, filename);
+  }
+  void writeImage(fitsfile* fptr, const std::string& filename,
+                  const float* image, long* currentPixel) const {
+    float nullValue = std::numeric_limits<float>::max();
+    int status = 0;
+    fits_write_pixnull(fptr, TFLOAT, currentPixel, _width * _height,
+                       const_cast<float*>(image), &nullValue, &status);
+    checkStatus(status, filename);
+  }
+
+  template <typename NumType>
+  void writeImage(fitsfile* fptr, const std::string& filename,
+                  const NumType* image, long* currentPixel) const {
+    double nullValue = std::numeric_limits<double>::max();
+    int status = 0;
+    size_t totalSize = _width * _height;
+    std::vector<double> copy(totalSize);
+    for (size_t i = 0; i != totalSize; ++i) copy[i] = image[i];
+    fits_write_pixnull(fptr, TDOUBLE, currentPixel, totalSize, &copy[0],
+                       &nullValue, &status);
+    checkStatus(status, filename);
+  }
+
+  std::string _multiFilename;
+  fitsfile* _multiFPtr;
+  std::vector<long> _currentPixel;
+};
+}  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/hmatrix4x4.h
@@ -0,0 +1,215 @@
+#ifndef HMATRIX_4X4_H
+#define HMATRIX_4X4_H
+
+#include <complex>
+#include <string>
+#include <sstream>
+#include <stdexcept>
+
+#include <aocommon/matrix2x2.h>
+#include <aocommon/matrix4x4.h>
+
+namespace aocommon {
+class HMatrix4x4 {
+ public:
+  HMatrix4x4() { std::fill_n(_data, 16, 0.0); }
+
+  explicit HMatrix4x4(const aocommon::Matrix4x4& src) {
+    // row 0
+    _data[0] = src[0].real();
+
+    // row 1
+    _data[1] = src[4].real();
+    _data[2] = src[4].imag();
+    _data[3] = src[5].real();
+
+    // row 2
+    _data[4] = src[8].real();
+    _data[5] = src[8].imag();
+    _data[6] = src[9].real();
+    _data[7] = src[9].imag();
+    _data[8] = src[10].real();
+
+    // row 3
+    _data[9] = src[12].real();
+    _data[10] = src[12].imag();
+    _data[11] = src[13].real();
+    _data[12] = src[13].imag();
+    _data[13] = src[14].real();
+    _data[14] = src[14].imag();
+    _data[15] = src[15].real();
+  }
+
+  HMatrix4x4(std::initializer_list<std::complex<double>> list) {
+    *this = HMatrix4x4(aocommon::Matrix4x4(list));
+  }
+
+  static HMatrix4x4 FromData(std::initializer_list<double> list) {
+    if (list.size() != 16)
+      throw std::runtime_error("FromData parameter should have 16 elements");
+    HMatrix4x4 m;
+    double* ptr = m._data;
+    for (double e : list) {
+      *ptr = e;
+      ++ptr;
+    }
+    return m;
+  }
+
+  static HMatrix4x4 Zero() { return HMatrix4x4(); }
+
+  static HMatrix4x4 Unit() {
+    HMatrix4x4 unit;
+    unit._data[0] = 1.0;
+    unit._data[3] = 1.0;
+    unit._data[8] = 1.0;
+    unit._data[15] = 1.0;
+    return unit;
+  }
+
+  HMatrix4x4& operator+=(const HMatrix4x4& rhs) {
+    for (size_t i = 0; i != 16; ++i) _data[i] += rhs._data[i];
+    return *this;
+  }
+
+  HMatrix4x4 operator*(double rhs) const {
+    HMatrix4x4 m;
+    for (size_t i = 0; i != 16; ++i) m._data[i] = _data[i] * rhs;
+    return m;
+  }
+
+  aocommon::Vector4 operator*(const aocommon::Vector4& rhs) const {
+    aocommon::Vector4 v(_data[0] * rhs[0], (*this)[4] * rhs[0],
+                        (*this)[8] * rhs[0], (*this)[12] * rhs[0]);
+    v[0] += (*this)[1] * rhs[1];
+    v[1] += _data[3] * rhs[1];
+    v[2] += (*this)[1 + 8] * rhs[1];
+    v[3] += (*this)[1 + 12] * rhs[1];
+
+    v[0] += (*this)[2] * rhs[2];
+    v[1] += (*this)[2 + 4] * rhs[2];
+    v[2] += _data[8] * rhs[2];
+    v[3] += (*this)[2 + 12] * rhs[2];
+
+    v[0] += (*this)[3] * rhs[3];
+    v[1] += (*this)[3 + 4] * rhs[3];
+    v[2] += (*this)[3 + 8] * rhs[3];
+    v[3] += _data[15] * rhs[3];
+
+    return v;
+  }
+
+  HMatrix4x4& operator*=(double rhs) {
+    for (size_t i = 0; i != 16; ++i) _data[i] *= rhs;
+    return *this;
+  }
+
+  HMatrix4x4& operator/=(double rhs) {
+    for (size_t i = 0; i != 16; ++i) _data[i] /= rhs;
+    return *this;
+  }
+
+  bool Invert() {
+    aocommon::Matrix4x4 inv = ToMatrix();
+    if (!inv.Invert())
+      return false;
+    else {
+      *this = HMatrix4x4(inv);
+      return true;
+    }
+  }
+
+  std::complex<double> operator[](size_t i) const {
+    const size_t lookup[16] = {32, 17, 20, 25, 1, 35, 22, 27,
+                               4,  6,  40, 29, 9, 11, 13, 47};
+    const size_t l = lookup[i];
+    return ((l & 32) == 0)
+               ? (((l & 16) == 0)
+                      ? std::complex<double>(_data[l], _data[l + 1])
+                      : std::complex<double>(_data[l & (~16)],
+                                             -_data[(l & (~16)) + 1]))
+               : (_data[l & (~32)]);
+  }
+
+  aocommon::Matrix4x4 ToMatrix() const {
+    aocommon::Matrix4x4 m;
+    for (size_t i = 0; i != 16; ++i) {
+      m[i] = (*this)[i];
+    }
+    return m;
+  }
+
+  double Norm() const {
+    return
+        // diagonal
+        _data[0] * _data[0] + _data[3] * _data[3] + _data[8] * _data[8] +
+        _data[15] * _data[15] +
+        // lower half x 2
+        2.0 * (std::norm(toComplex(1)) + std::norm(toComplex(4)) +
+               std::norm(toComplex(6)) + std::norm(toComplex(9)) +
+               std::norm(toComplex(11)) + std::norm(toComplex(13)));
+  }
+
+  std::string String() const {
+    std::ostringstream str;
+    for (size_t y = 0; y != 4; ++y) {
+      for (size_t x = 0; x != 3; ++x) {
+        str << (*this)[x + y * 4] << '\t';
+      }
+      str << (*this)[3 + y * 4] << '\n';
+    }
+    return str.str();
+  }
+
+  static HMatrix4x4 KroneckerProduct(const aocommon::MC2x2& hma,
+                                     const aocommon::MC2x2& hmb) {
+    HMatrix4x4 result;
+
+    // top left submatrix
+    result._data[0] = (hma[0] * hmb[0]).real();
+    result.setComplex(1, hma[0] * hmb[2]);
+    result._data[3] = (hma[0] * hmb[3]).real();
+
+    // bottom left submatrix
+    result.setComplex(4, hma[2] * hmb[0]);
+    result.setComplex(6, hma[2] * hmb[1]);
+    result.setComplex(9, hma[2] * hmb[2]);
+    result.setComplex(11, hma[2] * hmb[3]);
+
+    // bottom right submatrix
+    result._data[8] = (hma[3] * hmb[0]).real();
+    result.setComplex(13, hma[3] * hmb[2]);
+    result._data[15] = (hma[3] * hmb[3]).real();
+
+    return result;
+  }
+
+  const double& Data(size_t index) const { return _data[index]; }
+  double& Data(size_t index) { return _data[index]; }
+
+ private:
+  std::complex<double> toComplex(size_t singleIndex) const {
+    return std::complex<double>(_data[singleIndex], _data[singleIndex + 1]);
+  }
+  void setComplex(size_t singleIndex, std::complex<double> val) {
+    _data[singleIndex] = val.real();
+    _data[singleIndex + 1] = val.imag();
+  }
+
+  /**
+   * Internally, the data is stored as 16 doubles. The diagonal
+   * is real, and only the lower (complex) half is stored, in
+   * column-first order. The elements can therefore be index in
+   * the following way:
+   *  0
+   *  1  3
+   *  4  6 8
+   *  9 11 13 15
+   */
+  double _data[16];
+};
+
+typedef HMatrix4x4 HMC4x4;
+}  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/imagecoordinates.h
@@ -0,0 +1,140 @@
+#ifndef IMAGE_COORDINATES_H
+#define IMAGE_COORDINATES_H
+
+#include <algorithm>
+#include <cmath>
+#include <vector>
+
+namespace aocommon {
+
+/**
+ * This class collects all the LM coordinate transform as defined in
+ * Perley (1999)'s "imaging with non-coplaner arrays".
+ */
+class ImageCoordinates {
+ public:
+  template <typename T>
+  static void RaDecToLM(T ra, T dec, T phaseCentreRa, T phaseCentreDec,
+                        T &destL, T &destM) {
+    const T deltaAlpha = ra - phaseCentreRa, sinDeltaAlpha = sin(deltaAlpha),
+            cosDeltaAlpha = cos(deltaAlpha), sinDec = sin(dec),
+            cosDec = cos(dec), sinDec0 = sin(phaseCentreDec),
+            cosDec0 = cos(phaseCentreDec);
+
+    destL = cosDec * sinDeltaAlpha;
+    destM = sinDec * cosDec0 - cosDec * sinDec0 * cosDeltaAlpha;
+  }
+
+  template <typename T>
+  static T RaDecToN(T ra, T dec, T phaseCentreRa, T phaseCentreDec) {
+    const T cosDeltaAlpha = cos(ra - phaseCentreRa), sinDec = sin(dec),
+            cosDec = cos(dec), sinDec0 = sin(phaseCentreDec),
+            cosDec0 = cos(phaseCentreDec);
+
+    return sinDec * sinDec0 + cosDec * cosDec0 * cosDeltaAlpha;
+  }
+
+  template <typename T>
+  static void LMToRaDec(T l, T m, T phaseCentreRa, T phaseCentreDec, T &destRa,
+                        T &destDec) {
+    const T cosDec0 = cos(phaseCentreDec), sinDec0 = sin(phaseCentreDec),
+            lmTerm = sqrt((T)1.0 - l * l - m * m),
+            deltaAlpha = atan2(l, lmTerm * cosDec0 - m * sinDec0);
+
+    destRa = deltaAlpha + phaseCentreRa;
+    destDec = asin(m * cosDec0 + lmTerm * sinDec0);
+  }
+
+  template <typename T>
+  static void XYToLM(size_t x, size_t y, T pixelSizeX, T pixelSizeY,
+                     size_t width, size_t height, T &l, T &m) {
+    T midX = (T)width / 2.0, midY = (T)height / 2.0;
+    l = (midX - (T)x) * pixelSizeX;
+    m = ((T)y - midY) * pixelSizeY;
+  }
+
+  template <typename T>
+  static void LMToXY(T l, T m, T pixelSizeX, T pixelSizeY, size_t width,
+                     size_t height, int &x, int &y) {
+    T midX = (T)width / 2.0, midY = (T)height / 2.0;
+    x = round(-l / pixelSizeX) + midX;
+    y = round(m / pixelSizeY) + midY;
+  }
+
+  template <typename T>
+  static void LMToXYfloat(T l, T m, T pixelSizeX, T pixelSizeY, size_t width,
+                          size_t height, T &x, T &y) {
+    T midX = (T)width / 2.0, midY = (T)height / 2.0;
+    x = -l / pixelSizeX + midX;
+    y = m / pixelSizeY + midY;
+  }
+
+  template <typename T>
+  static T AngularDistance(T ra1, T dec1, T ra2, T dec2) {
+    T sinDec1, sinDec2, cosDec1, cosDec2;
+    SinCos(dec1, &sinDec1, &cosDec1);
+    SinCos(dec2, &sinDec2, &cosDec2);
+    T cosVal = sinDec1 * sinDec2 + cosDec1 * cosDec2 * std::cos(ra1 - ra2);
+    // Rounding errors sometimes cause cosVal to be slightly larger than 1,
+    // which would cause an NaN return value.
+    return cosVal <= 1.0 ? std::acos(cosVal) : 0.0;
+  }
+
+  template <typename T>
+  static T MeanRA(const std::vector<T> &raValues) {
+    std::vector<T> sorted(raValues);
+    for (size_t i = 0; i != sorted.size(); ++i) {
+      while (sorted[i] >= 2 * M_PI) sorted[i] -= 2.0 * M_PI;
+      while (sorted[i] < 0.0) sorted[i] += 2.0 * M_PI;
+    }
+    std::sort(sorted.begin(), sorted.end());
+    T gapSize = 0.0, gapCentre = 0.0;
+    for (size_t i = 0; i != sorted.size(); ++i) {
+      double dist;
+      if (i == sorted.size() - 1)
+        dist = 2.0 * M_PI + sorted.front() - sorted.back();
+      else
+        dist = sorted[i + 1] - sorted[i];
+      if (dist > gapSize) {
+        gapSize = dist;
+        gapCentre = sorted[i] + gapSize * 0.5;
+      }
+    }
+    if (gapCentre >= 2.0 * M_PI) gapCentre -= 2.0 * M_PI;
+    T sum = 0.0;
+    for (size_t i = 0; i != sorted.size(); ++i) {
+      if (sorted[i] < gapCentre)
+        sum += sorted[i];
+      else
+        sum += sorted[i] - 2.0 * M_PI;
+    }
+    sum /= sorted.size();
+    if (sum < 0.0)
+      return sum + 2.0 * M_PI;
+    else
+      return sum;
+  }
+
+ private:
+  static void SinCos(double angle, double *sinAngle, double *cosAngle) {
+    *sinAngle = std::sin(angle);
+    *cosAngle = std::cos(angle);
+  }
+
+  static void SinCos(long double angle, long double *sinAngle,
+                     long double *cosAngle) {
+    *sinAngle = std::sin(angle);
+    *cosAngle = std::cos(angle);
+  }
+
+  static void SinCos(float angle, float *sinAngle, float *cosAngle) {
+    *sinAngle = std::sin(angle);
+    *cosAngle = std::cos(angle);
+  }
+
+  ImageCoordinates();
+};
+
+}  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/lane.h
@@ -0,0 +1,572 @@
+#ifndef AO_LANE_11_H
+#define AO_LANE_11_H
+
+#include <condition_variable>
+#include <cstring>
+#include <deque>
+#include <mutex>
+
+/**
+ * @file
+ * Internal header file for the Lane.
+ * @headername{Lane.h}
+ */
+
+//#define LANE_DEBUG_MODE
+
+#ifdef LANE_DEBUG_MODE
+#include <cmath>
+#include <iostream>
+#include <sstream>
+#include <string>
+#endif
+
+namespace aocommon {
+
+#ifdef LANE_DEBUG_MODE
+#define set_lane_debug_name(lane, str) (lane).setDebugName(str)
+#define LANE_REGISTER_DEBUG_INFO registerDebugInfo()
+#define LANE_REGISTER_DEBUG_WRITE_WAIT registerDebugWriteWait()
+#define LANE_REGISTER_DEBUG_READ_WAIT registerDebugReadWait()
+#define LANE_REPORT_DEBUG_INFO reportDebugInfo()
+
+#else
+
+#define set_lane_debug_name(lane, str)
+#define LANE_REGISTER_DEBUG_INFO
+#define LANE_REGISTER_DEBUG_WRITE_WAIT
+#define LANE_REGISTER_DEBUG_READ_WAIT
+#define LANE_REPORT_DEBUG_INFO
+
+#endif
+
+/**
+ * @brief The Lane is an efficient cyclic buffer that is synchronized.
+ * @details
+ * A Lane can typically be used in a multi-threaded producer-consumer
+ * situation. The Lane also holds a state which allows for
+ * an ellegant way of communicating from producer(s) to
+ * consumer(s) that all data has been produced.
+ *
+ * A simple example:
+ * @code
+ * void producer(Lane<Task>* taskLane)
+ * {
+ *   while(moreTasks)
+ *     taskLane->write(nextTask());
+ *   taskLane->write_end();
+ * }
+ *
+ * void consumer(Lane<Task>* taskLane)
+ * {
+ *   Task task;
+ *   while(taskLane->read(task))
+ *     processTask(task);
+ * }
+ *
+ * void run()
+ * {
+ *   Lane<Task> taskLane;
+ *   std::thread consumerThread(&consumer(), &taskLane);
+ *   producer(&taskLane);
+ *   consumerThread.join();
+ * }
+ * @endcode
+ *
+ * The various read and write methods, as well as the empty(),
+ * capacity() and size() methods are always thread safe. The other
+ * methods are not: assignment, swap(), clear() and resize() can not
+ * be called from a different thread while another thread is also
+ * accessing the Lane. The same holds obviously for the constructors
+ * and destructor. This is chosen because these methods should almost never
+ * be called in parallel with other methods, and hence it is not worth
+ * to increase every call with extra locks to make this possible.
+ *
+ * With one reader and one writer, the order is guaranteed to be consistent.
+ * With multiple readers or writers in combination with multi-element
+ * write or read functions, a sequence of symbols might be interrupted. For
+ * example, if a multi-element write() won't fit completely in the buffer,
+ * the thread will wait for free space. Another thread might get now write
+ * access first, causing the single call to the multi-element write to be
+ * "split up".
+ *
+ * @author Andre Offringa
+ * @tparam Tp Type of elements to be stored in the Lane.
+ */
+template <typename Tp>
+class Lane {
+ public:
+  /** @brief Integer type used to store size types. */
+  typedef std::size_t size_type;
+
+  /** @brief Type of elements stored in the Lane. */
+  typedef Tp value_type;
+
+  /** @brief Construct a Lane with zero elements.
+   * @details A Lane with zero elements can not be written to or read to
+   * (both operations will wait forever).
+   *
+   * This constructor makes it easy to construct e.g. a container
+   * of Lanes. After the container is created, the Lanes can be
+   * resized with @ref resize().
+   */
+  Lane() noexcept
+      : _buffer(0),
+        _capacity(0),
+        _write_position(0),
+        _free_write_space(0),
+        _status(status_normal) {}
+
+  /** @brief Construct a Lane with the given capacity.
+   * @details After construction, the Lane is ready for writing to and reading
+   * from.
+   * @param capacity Number of elements that the Lane can hold at once.
+   */
+  explicit Lane(size_t capacity)
+      : _buffer(new Tp[capacity]),
+        _capacity(capacity),
+        _write_position(0),
+        _free_write_space(_capacity),
+        _status(status_normal) {}
+
+  Lane(const Lane<Tp> &source) = delete;
+
+  /** @brief Move construct a Lane.
+   * @details This operation is not thread safe: the behaviour is undefined when
+   * other threads access the source Lane.
+   * @param source Original Lane to be moved from.
+   */
+  Lane(Lane<Tp> &&source) noexcept
+      : _buffer(0),
+        _capacity(0),
+        _write_position(0),
+        _free_write_space(0),
+        _status(status_normal) {
+    swap(source);
+  }
+
+  /** @brief Destructor.
+   * @details The destructor is not synchronized.
+   */
+  ~Lane() {
+    LANE_REPORT_DEBUG_INFO;
+    delete[] _buffer;
+  }
+
+  Lane<Tp> &operator=(const Lane<Tp> &source) = delete;
+
+  /** @brief Move assignment.
+   * @details This operation is not thread safe: the behaviour is undefined when
+   * other threads access the source Lane.
+   * @param source Original Lane to be moved from.
+   * @returns This Lane.
+   */
+  Lane<Tp> &operator=(Lane<Tp> &&source) noexcept {
+    swap(source);
+    return *this;
+  }
+
+  /** @brief Swap the contents of this Lane with another.
+   * @details This operation is not thread safe: the behaviour is undefined when
+   * other threads access either Lane.
+   */
+  void swap(Lane<Tp> &other) noexcept {
+    std::swap(_buffer, other._buffer);
+    std::swap(_capacity, other._capacity);
+    std::swap(_write_position, other._write_position);
+    std::swap(_free_write_space, other._free_write_space);
+    std::swap(_status, other._status);
+  }
+
+  /** @brief Clear the contents and reset the state of the Lane.
+   * @details After calling clear(), the Lane is in the same state as after
+   * construction. This also means that after clearing the Lane, it
+   * is as if write_end() has not been called yet.
+   *
+   * This method is not thread safe.
+   */
+  void clear() noexcept {
+    _write_position = 0;
+    _free_write_space = _capacity;
+    _status = status_normal;
+  }
+
+  /** @brief Write a single element.
+   * @details This method is thread safe, and can be called together with
+   * other write and read methods from different threads.
+   *
+   * If this call comes after a call to write_end(), the call
+   * will be ignored.
+   * @param element Object to be copied into the cyclic buffer.
+   */
+  void write(const value_type &element) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+
+    if (_status == status_normal) {
+      while (_free_write_space == 0) {
+        LANE_REGISTER_DEBUG_WRITE_WAIT;
+        _writing_possible_condition.wait(lock);
+      }
+
+      _buffer[_write_position] = element;
+      _write_position = (_write_position + 1) % _capacity;
+      --_free_write_space;
+      // Now that there is less free write space, there is more free read
+      // space and thus readers can possibly continue.
+      _reading_possible_condition.notify_all();
+    }
+  }
+
+  /** @brief Write a single element by constructing it.
+   * @details This method is thread safe, and can be called together with
+   * other write and read methods from different threads.
+   *
+   * If this call comes after a call to write_end(), the call
+   * will be ignored. The implementation does not construct the value
+   * in place, but rather constructs the value and then move assigns it.
+   * This is because the value that it is moved into has already been
+   * constructed (in the current implementation).
+   * @param element Object to be moved into the cyclic buffer.
+   */
+  template <typename... Args>
+  void emplace(Args &&... args) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+
+    if (_status == status_normal) {
+      while (_free_write_space == 0) {
+        LANE_REGISTER_DEBUG_WRITE_WAIT;
+        _writing_possible_condition.wait(lock);
+      }
+
+      _buffer[_write_position] = value_type(args...);
+      _write_position = (_write_position + 1) % _capacity;
+      --_free_write_space;
+      // Now that there is less free write space, there is more free read
+      // space and thus readers can possibly continue.
+      _reading_possible_condition.notify_all();
+    }
+  }
+
+  /** @brief Write a single element by moving it in.
+   * @details This method is thread safe, and can be called together with
+   * other write and read methods from different threads.
+   *
+   * If this call comes after a call to write_end(), the call
+   * will be ignored.
+   * @param element Object to be moved into the cyclic buffer.
+   */
+  void write(value_type &&element) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+
+    if (_status == status_normal) {
+      while (_free_write_space == 0) {
+        LANE_REGISTER_DEBUG_WRITE_WAIT;
+        _writing_possible_condition.wait(lock);
+      }
+
+      _buffer[_write_position] = std::move(element);
+      _write_position = (_write_position + 1) % _capacity;
+      --_free_write_space;
+      // Now that there is less free write space, there is more free read
+      // space and thus readers can possibly continue.
+      _reading_possible_condition.notify_all();
+    }
+  }
+
+  void write(const value_type *elements, size_t n) {
+    write_generic(elements, n);
+  }
+
+  void move_write(value_type *elements, size_t n) {
+    write_generic(elements, n);
+  }
+
+  bool read(value_type &destination) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+    while (free_read_space() == 0 && _status == status_normal) {
+      LANE_REGISTER_DEBUG_READ_WAIT;
+      _reading_possible_condition.wait(lock);
+    }
+    if (free_read_space() == 0)
+      return false;
+    else {
+      destination = std::move(_buffer[read_position()]);
+      ++_free_write_space;
+      // Now that there is more free write space, writers can possibly continue.
+      _writing_possible_condition.notify_all();
+      return true;
+    }
+  }
+
+  size_t read(value_type *destinations, size_t n) {
+    size_t n_left = n;
+
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+
+    size_t free_space = free_read_space();
+    size_t read_size = free_space > n ? n : free_space;
+    immediate_read(destinations, read_size);
+    n_left -= read_size;
+
+    while (n_left != 0 && _status == status_normal) {
+      destinations += read_size;
+
+      do {
+        LANE_REGISTER_DEBUG_READ_WAIT;
+        _reading_possible_condition.wait(lock);
+      } while (free_read_space() == 0 && _status == status_normal);
+
+      free_space = free_read_space();
+      read_size = free_space > n_left ? n_left : free_space;
+      immediate_read(destinations, read_size);
+      n_left -= read_size;
+    }
+    return n - n_left;
+  }
+
+  /**
+   * This method does the same thing as read(buffer, n) but discards the data.
+   * This eliminates the requirement to specify a buffer if the data is not
+   * necessary anyway, and avoids a copy of the data.
+   */
+  size_t discard(size_t n) {
+    size_t n_left = n;
+
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+
+    size_t free_space = free_read_space();
+    size_t read_size = free_space > n ? n : free_space;
+    immediate_discard(read_size);
+    n_left -= read_size;
+
+    while (n_left != 0 && _status == status_normal) {
+      do {
+        LANE_REGISTER_DEBUG_READ_WAIT;
+        _reading_possible_condition.wait(lock);
+      } while (free_read_space() == 0 && _status == status_normal);
+
+      free_space = free_read_space();
+      read_size = free_space > n_left ? n_left : free_space;
+      immediate_discard(read_size);
+      n_left -= read_size;
+    }
+    return n - n_left;
+  }
+
+  void write_end() {
+    std::lock_guard<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+    _status = status_end;
+    _writing_possible_condition.notify_all();
+    _reading_possible_condition.notify_all();
+  }
+
+  size_t capacity() const noexcept { return _capacity; }
+
+  size_t size() const {
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _capacity - _free_write_space;
+  }
+
+  bool empty() const {
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _capacity == _free_write_space;
+  }
+
+  /**
+   * Change the capacity of the Lane. This will erase all data in the Lane.
+   */
+  void resize(size_t new_capacity) {
+    Tp *new_buffer = new Tp[new_capacity];
+    delete[] _buffer;
+    _buffer = new_buffer;
+    _capacity = new_capacity;
+    _write_position = 0;
+    _free_write_space = new_capacity;
+    _status = status_normal;
+  }
+
+  /**
+   * Wait until this Lane is empty.
+   */
+  void wait_for_empty() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    while (_capacity != _free_write_space) {
+      _writing_possible_condition.wait(lock);
+    }
+  }
+
+#ifdef LANE_DEBUG_MODE
+  /**
+   * Change the name of this Lane to make it appear in the output along
+   * with statistics. Do not use this function directly; use the
+   * set_lane_debug_name() macro instead.
+   * @param nameStr New debug description of this Lane.
+   */
+  void setDebugName(const std::string &nameStr) { _debugName = nameStr; }
+#endif
+ private:
+  Tp *_buffer;
+
+  size_t _capacity;
+
+  size_t _write_position;
+
+  size_t _free_write_space;
+
+  enum { status_normal, status_end } _status;
+
+  mutable std::mutex _mutex;
+
+  std::condition_variable _writing_possible_condition,
+      _reading_possible_condition;
+
+  size_t read_position() const noexcept {
+    return (_write_position + _free_write_space) % _capacity;
+  }
+
+  size_t free_read_space() const noexcept {
+    return _capacity - _free_write_space;
+  }
+
+  // This is a template to allow const and non-const (to be able to move)
+  template <typename T>
+  void write_generic(T *elements, size_t n) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    LANE_REGISTER_DEBUG_INFO;
+
+    if (_status == status_normal) {
+      size_t write_size = _free_write_space > n ? n : _free_write_space;
+      immediate_write(elements, write_size);
+      n -= write_size;
+
+      while (n != 0) {
+        elements += write_size;
+
+        do {
+          LANE_REGISTER_DEBUG_WRITE_WAIT;
+          _writing_possible_condition.wait(lock);
+        } while (_free_write_space == 0 && _status == status_normal);
+
+        write_size = _free_write_space > n ? n : _free_write_space;
+        immediate_write(elements, write_size);
+        n -= write_size;
+      }
+      while (n != 0)
+        ;
+    }
+  }
+
+  // This is a template to allow const and non-const (to be able to move)
+  template <typename T>
+  void immediate_write(T *elements, size_t n) noexcept {
+    // Split the writing in two ranges if needed. The first range fits in
+    // [_write_position, _capacity), the second range in [0, end). By doing
+    // so, we only have to calculate the modulo in the write position once.
+    if (n > 0) {
+      size_t nPart;
+      if (_write_position + n > _capacity) {
+        nPart = _capacity - _write_position;
+      } else {
+        nPart = n;
+      }
+      for (size_t i = 0; i < nPart; ++i, ++_write_position) {
+        _buffer[_write_position] = std::move(elements[i]);
+      }
+
+      _write_position = _write_position % _capacity;
+
+      for (size_t i = nPart; i < n; ++i, ++_write_position) {
+        _buffer[_write_position] = std::move(elements[i]);
+      }
+
+      _free_write_space -= n;
+
+      // Now that there is less free write space, there is more free read
+      // space and thus readers can possibly continue.
+      _reading_possible_condition.notify_all();
+    }
+  }
+
+  void immediate_read(value_type *elements, size_t n) noexcept {
+    // As with write, split in two ranges if needed. The first range fits in
+    // [read_position(), _capacity), the second range in [0, end).
+    if (n > 0) {
+      size_t nPart;
+      size_t position = read_position();
+      if (position + n > _capacity) {
+        nPart = _capacity - position;
+      } else {
+        nPart = n;
+      }
+      for (size_t i = 0; i < nPart; ++i, ++position) {
+        elements[i] = std::move(_buffer[position]);
+      }
+
+      position = position % _capacity;
+
+      for (size_t i = nPart; i < n; ++i, ++position) {
+        elements[i] = std::move(_buffer[position]);
+      }
+
+      _free_write_space += n;
+
+      // Now that there is more free write space, writers can possibly continue.
+      _writing_possible_condition.notify_all();
+    }
+  }
+
+  void immediate_discard(size_t n) noexcept {
+    if (n > 0) {
+      _free_write_space += n;
+
+      // Now that there is more free write space, writers can possibly continue.
+      _writing_possible_condition.notify_all();
+    }
+  }
+
+#ifdef LANE_DEBUG_MODE
+  void registerDebugInfo() noexcept {
+    _debugSummedSize += _capacity - _free_write_space;
+    _debugMeasureCount++;
+  }
+  void registerDebugReadWait() noexcept { ++_debugReadWaitCount; }
+  void registerDebugWriteWait() noexcept { ++_debugWriteWaitCount; }
+  void reportDebugInfo() {
+    if (!_debugName.empty()) {
+      std::stringstream str;
+      str << "*** Debug report for the following Lane: ***\n"
+          << "\"" << _debugName << "\"\n"
+          << "Capacity: " << _capacity << '\n'
+          << "Total read/write ops: " << _debugMeasureCount << '\n'
+          << "Average size of buffer, measured per read/write op.: "
+          << round(double(_debugSummedSize) * 100.0 / _debugMeasureCount) /
+                 100.0
+          << '\n'
+          << "Number of wait events during reading: " << _debugReadWaitCount
+          << '\n'
+          << "Number of wait events during writing: " << _debugWriteWaitCount
+          << '\n';
+      std::cout << str.str();
+    }
+  }
+  std::string _debugName;
+  size_t _debugSummedSize = 0, _debugMeasureCount = 0, _debugReadWaitCount = 0,
+         _debugWriteWaitCount = 0;
+#endif
+};
+
+template <typename Tp>
+void swap(aocommon::Lane<Tp> &first, aocommon::Lane<Tp> &second) noexcept {
+  first.swap(second);
+}
+
+}  // namespace aocommon
+
+#endif  // AO_LANE11_H
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/matrix2x2.h
@@ -0,0 +1,637 @@
+#ifndef MATRIX_2X2_H
+#define MATRIX_2X2_H
+
+#include <cmath>
+#include <complex>
+#include <limits>
+#include <sstream>
+
+namespace aocommon {
+
+class Vector4 {
+ public:
+  Vector4(){};
+  Vector4(std::complex<double> a, std::complex<double> b,
+          std::complex<double> c, std::complex<double> d) {
+    _data[0] = a;
+    _data[1] = b;
+    _data[2] = c;
+    _data[3] = d;
+  };
+  std::complex<double>& operator[](size_t i) { return _data[i]; }
+  const std::complex<double>& operator[](size_t i) const { return _data[i]; }
+  std::complex<double>* data() { return _data; }
+  const std::complex<double>* data() const { return _data; }
+
+ private:
+  std::complex<double> _data[4];
+};
+
+class Matrix2x2 {
+ public:
+  template <typename LHS_T, typename RHS_T>
+  static void Assign(std::complex<LHS_T>* dest,
+                     const std::complex<RHS_T>* source) {
+    for (size_t p = 0; p != 4; ++p) dest[p] = source[p];
+  }
+
+  template <typename LHS_T, typename RHS_T>
+  static void Assign(LHS_T* dest, const RHS_T* source) {
+    for (size_t p = 0; p != 4; ++p) dest[p] = source[p];
+  }
+
+  template <typename T, typename RHS_T>
+  static void Add(std::complex<T>* dest, const RHS_T* rhs) {
+    for (size_t p = 0; p != 4; ++p) dest[p] += rhs[p];
+  }
+
+  template <typename T>
+  static void Subtract(std::complex<T>* dest, const std::complex<T>* rhs) {
+    for (size_t p = 0; p != 4; ++p) dest[p] -= rhs[p];
+  }
+
+  template <typename T>
+  static bool IsFinite(const std::complex<T>* matrix) {
+    return std::isfinite(matrix[0].real()) && std::isfinite(matrix[0].imag()) &&
+           std::isfinite(matrix[1].real()) && std::isfinite(matrix[1].imag()) &&
+           std::isfinite(matrix[2].real()) && std::isfinite(matrix[2].imag()) &&
+           std::isfinite(matrix[3].real()) && std::isfinite(matrix[3].imag());
+  }
+
+  template <typename T>
+  static void ScalarMultiply(std::complex<T>* dest, T factor) {
+    for (size_t p = 0; p != 4; ++p) dest[p] *= factor;
+  }
+
+  template <typename T>
+  static void ScalarMultiply(T* dest, T factor) {
+    for (size_t p = 0; p != 4; ++p) dest[p] *= factor;
+  }
+
+  template <typename T, typename RHS>
+  static void MultiplyAdd(std::complex<T>* dest, const RHS* rhs, T factor) {
+    for (size_t p = 0; p != 4; ++p) dest[p] += rhs[p] * factor;
+  }
+
+  template <typename ComplType, typename LHS_T, typename RHS_T>
+  static void ATimesB(std::complex<ComplType>* dest, const LHS_T* lhs,
+                      const RHS_T* rhs) {
+    dest[0] = lhs[0] * rhs[0] + lhs[1] * rhs[2];
+    dest[1] = lhs[0] * rhs[1] + lhs[1] * rhs[3];
+    dest[2] = lhs[2] * rhs[0] + lhs[3] * rhs[2];
+    dest[3] = lhs[2] * rhs[1] + lhs[3] * rhs[3];
+  }
+
+  static void PlusATimesB(std::complex<double>* dest,
+                          const std::complex<double>* lhs,
+                          const std::complex<double>* rhs) {
+    dest[0] += lhs[0] * rhs[0] + lhs[1] * rhs[2];
+    dest[1] += lhs[0] * rhs[1] + lhs[1] * rhs[3];
+    dest[2] += lhs[2] * rhs[0] + lhs[3] * rhs[2];
+    dest[3] += lhs[2] * rhs[1] + lhs[3] * rhs[3];
+  }
+
+  template <typename ComplType, typename LHS_T, typename RHS_T>
+  static void ATimesHermB(std::complex<ComplType>* dest, const LHS_T* lhs,
+                          const RHS_T* rhs) {
+    dest[0] = lhs[0] * std::conj(rhs[0]) + lhs[1] * std::conj(rhs[1]);
+    dest[1] = lhs[0] * std::conj(rhs[2]) + lhs[1] * std::conj(rhs[3]);
+    dest[2] = lhs[2] * std::conj(rhs[0]) + lhs[3] * std::conj(rhs[1]);
+    dest[3] = lhs[2] * std::conj(rhs[2]) + lhs[3] * std::conj(rhs[3]);
+  }
+
+  template <typename ComplType, typename LHS_T, typename RHS_T>
+  static void PlusATimesHermB(std::complex<ComplType>* dest, const LHS_T* lhs,
+                              const RHS_T* rhs) {
+    dest[0] += lhs[0] * std::conj(rhs[0]) + lhs[1] * std::conj(rhs[1]);
+    dest[1] += lhs[0] * std::conj(rhs[2]) + lhs[1] * std::conj(rhs[3]);
+    dest[2] += lhs[2] * std::conj(rhs[0]) + lhs[3] * std::conj(rhs[1]);
+    dest[3] += lhs[2] * std::conj(rhs[2]) + lhs[3] * std::conj(rhs[3]);
+  }
+
+  template <typename ComplType, typename LHS_T, typename RHS_T>
+  static void HermATimesB(std::complex<ComplType>* dest, const LHS_T* lhs,
+                          const RHS_T* rhs) {
+    dest[0] = std::conj(lhs[0]) * rhs[0] + std::conj(lhs[2]) * rhs[2];
+    dest[1] = std::conj(lhs[0]) * rhs[1] + std::conj(lhs[2]) * rhs[3];
+    dest[2] = std::conj(lhs[1]) * rhs[0] + std::conj(lhs[3]) * rhs[2];
+    dest[3] = std::conj(lhs[1]) * rhs[1] + std::conj(lhs[3]) * rhs[3];
+  }
+
+  static void HermATimesHermB(std::complex<double>* dest,
+                              const std::complex<double>* lhs,
+                              const std::complex<double>* rhs) {
+    dest[0] = std::conj(lhs[0]) * std::conj(rhs[0]) +
+              std::conj(lhs[2]) * std::conj(rhs[1]);
+    dest[1] = std::conj(lhs[0]) * std::conj(rhs[2]) +
+              std::conj(lhs[2]) * std::conj(rhs[3]);
+    dest[2] = std::conj(lhs[1]) * std::conj(rhs[0]) +
+              std::conj(lhs[3]) * std::conj(rhs[1]);
+    dest[3] = std::conj(lhs[1]) * std::conj(rhs[2]) +
+              std::conj(lhs[3]) * std::conj(rhs[3]);
+  }
+
+  template <typename ComplType, typename LHS_T, typename RHS_T>
+  static void PlusHermATimesB(std::complex<ComplType>* dest, const LHS_T* lhs,
+                              const RHS_T* rhs) {
+    dest[0] += std::conj(lhs[0]) * rhs[0] + std::conj(lhs[2]) * rhs[2];
+    dest[1] += std::conj(lhs[0]) * rhs[1] + std::conj(lhs[2]) * rhs[3];
+    dest[2] += std::conj(lhs[1]) * rhs[0] + std::conj(lhs[3]) * rhs[2];
+    dest[3] += std::conj(lhs[1]) * rhs[1] + std::conj(lhs[3]) * rhs[3];
+  }
+
+  template <typename T>
+  static bool Invert(T* matrix) {
+    T d = ((matrix[0] * matrix[3]) - (matrix[1] * matrix[2]));
+    if (d == T(0.0)) return false;
+    T oneOverDeterminant = T(1.0) / d;
+    T temp;
+    temp = matrix[3] * oneOverDeterminant;
+    matrix[1] = -matrix[1] * oneOverDeterminant;
+    matrix[2] = -matrix[2] * oneOverDeterminant;
+    matrix[3] = matrix[0] * oneOverDeterminant;
+    matrix[0] = temp;
+    return true;
+  }
+
+  template <typename T>
+  static void ConjugateTranspose(T* matrix) {
+    matrix[0] = std::conj(matrix[0]);
+    T temp = matrix[1];
+    matrix[1] = std::conj(matrix[2]);
+    matrix[2] = std::conj(temp);
+    matrix[3] = std::conj(matrix[3]);
+  }
+
+  static bool MultiplyWithInverse(std::complex<double>* lhs,
+                                  const std::complex<double>* rhs) {
+    std::complex<double> d = ((rhs[0] * rhs[3]) - (rhs[1] * rhs[2]));
+    if (d == 0.0) return false;
+    std::complex<double> oneOverDeterminant = 1.0 / d;
+    std::complex<double> temp[4];
+    temp[0] = rhs[3] * oneOverDeterminant;
+    temp[1] = -rhs[1] * oneOverDeterminant;
+    temp[2] = -rhs[2] * oneOverDeterminant;
+    temp[3] = rhs[0] * oneOverDeterminant;
+
+    std::complex<double> temp2 = lhs[0];
+    lhs[0] = lhs[0] * temp[0] + lhs[1] * temp[2];
+    lhs[1] = temp2 * temp[1] + lhs[1] * temp[3];
+
+    temp2 = lhs[2];
+    lhs[2] = lhs[2] * temp[0] + lhs[3] * temp[2];
+    lhs[3] = temp2 * temp[1] + lhs[3] * temp[3];
+    return true;
+  }
+
+  static void SingularValues(const std::complex<double>* matrix, double& e1,
+                             double& e2) {
+    // This is not the ultimate fastest method, since we
+    // don't need to calculate the imaginary values of b,c at all.
+    // Calculate M M^H
+    std::complex<double> temp[4] = {
+        matrix[0] * std::conj(matrix[0]) + matrix[1] * std::conj(matrix[1]),
+        matrix[0] * std::conj(matrix[2]) + matrix[1] * std::conj(matrix[3]),
+        matrix[2] * std::conj(matrix[0]) + matrix[3] * std::conj(matrix[1]),
+        matrix[2] * std::conj(matrix[2]) + matrix[3] * std::conj(matrix[3])};
+    // Use quadratic formula, with a=1.
+    double b = -temp[0].real() - temp[3].real(),
+           c = temp[0].real() * temp[3].real() - (temp[1] * temp[2]).real(),
+           d = b * b - (4.0 * 1.0) * c, sqrtd = sqrt(d);
+
+    e1 = sqrt((-b + sqrtd) * 0.5);
+    e2 = sqrt((-b - sqrtd) * 0.5);
+  }
+
+  static void EigenValues(const double* matrix, double& e1, double& e2) {
+    double tr = matrix[0] + matrix[3];
+    double d = matrix[0] * matrix[3] - matrix[1] * matrix[2];
+    double term = sqrt(tr * tr * 0.25 - d);
+    double trHalf = tr * 0.5;
+    e1 = trHalf + term;
+    e2 = trHalf - term;
+  }
+
+  template <typename ValType>
+  static void EigenValues(const std::complex<ValType>* matrix,
+                          std::complex<ValType>& e1,
+                          std::complex<ValType>& e2) {
+    std::complex<ValType> tr = matrix[0] + matrix[3];
+    std::complex<ValType> d = matrix[0] * matrix[3] - matrix[1] * matrix[2];
+    std::complex<ValType> term = sqrt(tr * tr * ValType(0.25) - d);
+    std::complex<ValType> trHalf = tr * ValType(0.5);
+    e1 = trHalf + term;
+    e2 = trHalf - term;
+  }
+
+  static void EigenValuesAndVectors(const double* matrix, double& e1,
+                                    double& e2, double* vec1, double* vec2) {
+    double tr = matrix[0] + matrix[3];
+    double d = matrix[0] * matrix[3] - matrix[1] * matrix[2];
+    double term = std::sqrt(tr * tr * 0.25 - d);
+    double trHalf = tr * 0.5;
+    e1 = trHalf + term;
+    e2 = trHalf - term;
+    double limit = std::min(std::fabs(e1), std::fabs(e2)) * 1e-6;
+    if (std::fabs(matrix[2]) > limit) {
+      vec1[0] = matrix[3] - e1;
+      vec1[1] = -matrix[2];
+      vec2[0] = matrix[3] - e2;
+      vec2[1] = -matrix[2];
+    } else if (std::fabs(matrix[1]) > limit) {
+      vec1[0] = -matrix[1];
+      vec1[1] = matrix[0] - e1;
+      vec2[0] = -matrix[1];
+      vec2[1] = matrix[0] - e2;
+    } else {
+      // We know that A v = lambda v, and we know that v1 or v2 = [1, 0]:
+      double
+          // Evaluate for v = [1, 0] and see if the error is smaller for e1 than
+          // for e2
+          err1_0 = matrix[0] - e1,
+          err2_0 = matrix[0] - e2;
+      if (err1_0 * err1_0 < err2_0 * err2_0) {
+        vec1[0] = 1.0;
+        vec1[1] = 0.0;
+        vec2[0] = 0.0;
+        vec2[1] = 1.0;
+      } else {
+        vec1[0] = 0.0;
+        vec1[1] = 1.0;
+        vec2[0] = 1.0;
+        vec2[1] = 0.0;
+      }
+    }
+  }
+
+  static void EigenValuesAndVectors(const std::complex<double>* matrix,
+                                    std::complex<double>& e1,
+                                    std::complex<double>& e2,
+                                    std::complex<double>* vec1,
+                                    std::complex<double>* vec2) {
+    std::complex<double> tr = matrix[0] + matrix[3];
+    std::complex<double> d = matrix[0] * matrix[3] - matrix[1] * matrix[2];
+    std::complex<double> term = std::sqrt(tr * tr * 0.25 - d);
+    std::complex<double> trHalf = tr * 0.5;
+    e1 = trHalf + term;
+    e2 = trHalf - term;
+    double limit = std::min(std::abs(e1), std::abs(e2)) * 1e-6;
+    if (std::abs(matrix[2]) > limit) {
+      vec1[0] = matrix[3] - e1;
+      vec1[1] = -matrix[2];
+      vec2[0] = matrix[3] - e2;
+      vec2[1] = -matrix[2];
+    } else if (std::abs(matrix[1]) > limit) {
+      vec1[0] = -matrix[1];
+      vec1[1] = matrix[0] - e1;
+      vec2[0] = -matrix[1];
+      vec2[1] = matrix[0] - e2;
+    } else {
+      // We know that A v = lambda v, and we know that v1 or v2 = [1, 0]:
+      auto
+          // Evaluate for v = [1, 0] and see if the error is smaller for e1 than
+          // for e2
+          err1_0 = std::norm(matrix[0] - e1),
+          err2_0 = std::norm(matrix[0] - e2);
+      if (err1_0 < err2_0) {
+        vec1[0] = 1.0;
+        vec1[1] = 0.0;
+        vec2[0] = 0.0;
+        vec2[1] = 1.0;
+      } else {
+        vec1[0] = 0.0;
+        vec1[1] = 1.0;
+        vec2[0] = 1.0;
+        vec2[1] = 0.0;
+      }
+    }
+  }
+
+  static void SquareRoot(double* matrix) {
+    double tr = matrix[0] + matrix[3];
+    double d = matrix[0] * matrix[3] - matrix[1] * matrix[2];
+    double s = /*+/-*/ sqrt(d);
+    double t = /*+/-*/ sqrt(tr + 2.0 * s);
+    if (t != 0.0) {
+      matrix[0] = (matrix[0] + s) / t;
+      matrix[1] = (matrix[1] / t);
+      matrix[2] = (matrix[2] / t);
+      matrix[3] = (matrix[3] + s) / t;
+    } else {
+      if (matrix[0] == 0.0 && matrix[1] == 0.0 && matrix[2] == 0.0 &&
+          matrix[3] == 0.0) {
+        // done: it's the zero matrix
+      } else {
+        for (size_t i = 0; i != 4; ++i)
+          matrix[i] = std::numeric_limits<double>::quiet_NaN();
+      }
+    }
+  }
+
+  static void SquareRoot(std::complex<double>* matrix) {
+    std::complex<double> tr = matrix[0] + matrix[3];
+    std::complex<double> d = matrix[0] * matrix[3] - matrix[1] * matrix[2];
+    std::complex<double> s = /*+/-*/ sqrt(d);
+    std::complex<double> t = /*+/-*/ sqrt(tr + 2.0 * s);
+    if (t != 0.0) {
+      matrix[0] = (matrix[0] + s) / t;
+      matrix[1] = (matrix[1] / t);
+      matrix[2] = (matrix[2] / t);
+      matrix[3] = (matrix[3] + s) / t;
+    } else {
+      if (matrix[0] == 0.0 && matrix[1] == 0.0 && matrix[2] == 0.0 &&
+          matrix[3] == 0.0) {
+        // done: it's the zero matrix
+      } else {
+        for (size_t i = 0; i != 4; ++i)
+          matrix[i] =
+              std::complex<double>(std::numeric_limits<double>::quiet_NaN(),
+                                   std::numeric_limits<double>::quiet_NaN());
+      }
+    }
+  }
+
+  /**
+   * Calculates L, the lower triangle of the Cholesky decomposition, such that
+   * L L^H = M. The result is undefined when the matrix is not positive
+   * definite.
+   */
+  static void UncheckedCholesky(std::complex<double>* matrix) {
+    // solve:
+    // ( a 0 ) ( a* b* ) = ( aa* ;    ab*    )
+    // ( b c ) ( 0  c* )   ( a*b ; bb* + cc* )
+    // With a and c necessarily real.
+    double a = sqrt(matrix[0].real());
+    std::complex<double> b = std::conj(matrix[1] / a);
+    double bbConj = b.real() * b.real() + b.imag() * b.imag();
+    double c = sqrt(matrix[3].real() - bbConj);
+    matrix[0] = a;
+    matrix[1] = 0.0;
+    matrix[2] = b;
+    matrix[3] = c;
+  }
+
+  /**
+   * Calculates L, the lower triangle of the Cholesky decomposition, such that
+   * L L^H = M. Return false when the result would not be finite.
+   */
+  static bool Cholesky(std::complex<double>* matrix) {
+    if (matrix[0].real() < 0.0) return false;
+    double a = sqrt(matrix[0].real());
+    std::complex<double> b = std::conj(matrix[1] / a);
+    double bbConj = b.real() * b.real() + b.imag() * b.imag();
+    double cc = matrix[3].real() - bbConj;
+    if (cc < 0.0) return false;
+    double c = sqrt(cc);
+    matrix[0] = a;
+    matrix[1] = 0.0;
+    matrix[2] = b;
+    matrix[3] = c;
+    return true;
+  }
+
+  /**
+   * Calculates L, the lower triangle of the Cholesky decomposition, such that
+   * L L^H = M. Return false when the matrix was not positive semi-definite.
+   */
+  static bool CheckedCholesky(std::complex<double>* matrix) {
+    if (matrix[0].real() <= 0.0 || matrix[0].imag() != 0.0 ||
+        matrix[3].real() <= 0.0 || matrix[3].imag() != 0.0 ||
+        matrix[1] != std::conj(matrix[2]))
+      return false;
+    UncheckedCholesky(matrix);
+    return true;
+  }
+
+  template <typename T>
+  static T RotationAngle(const std::complex<T>* matrix) {
+    return std::atan2((matrix[2].real() - matrix[1].real()) * 0.5,
+                      (matrix[0].real() + matrix[3].real()) * 0.5);
+  }
+
+  template <typename T>
+  static void RotationMatrix(std::complex<T>* matrix, double alpha) {
+    T cosAlpha = std::cos(alpha), sinAlpha = std::sin(alpha);
+    matrix[0] = cosAlpha;
+    matrix[1] = -sinAlpha;
+    matrix[2] = sinAlpha;
+    matrix[3] = cosAlpha;
+  }
+};
+
+template <typename ValType>
+class MC2x2Base {
+ public:
+  MC2x2Base() {}
+  MC2x2Base(const MC2x2Base<ValType>& source) {
+    Matrix2x2::Assign(_values, source._values);
+  }
+  template <typename T>
+  explicit MC2x2Base(const T source[4]) {
+    Matrix2x2::Assign(_values, source);
+  }
+  MC2x2Base(ValType m00, ValType m01, ValType m10, ValType m11) {
+    _values[0] = m00;
+    _values[1] = m01;
+    _values[2] = m10;
+    _values[3] = m11;
+  }
+  MC2x2Base(std::complex<ValType> m00, std::complex<ValType> m01,
+            std::complex<ValType> m10, std::complex<ValType> m11) {
+    _values[0] = m00;
+    _values[1] = m01;
+    _values[2] = m10;
+    _values[3] = m11;
+  }
+  MC2x2Base<ValType>& operator=(const MC2x2Base<ValType>& source) {
+    Matrix2x2::Assign(_values, source._values);
+    return *this;
+  }
+  MC2x2Base<ValType> operator+(const MC2x2Base<ValType>& rhs) const {
+    MC2x2Base<ValType> result(*this);
+    Matrix2x2::Add(result._values, rhs._values);
+    return result;
+  }
+  MC2x2Base<ValType>& operator+=(const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::Add(_values, rhs._values);
+    return *this;
+  }
+  MC2x2Base<ValType>& operator-=(const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::Subtract(_values, rhs._values);
+    return *this;
+  }
+  MC2x2Base<ValType>& operator*=(const MC2x2Base<ValType>& rhs) {
+    MC2x2Base<ValType> dest;
+    Matrix2x2::ATimesB(dest._values, _values, rhs._values);
+    *this = dest;
+    return *this;
+  }
+  MC2x2Base<ValType> operator*(const MC2x2Base<ValType>& rhs) const {
+    MC2x2Base<ValType> dest;
+    Matrix2x2::ATimesB(dest._values, _values, rhs._values);
+    return dest;
+  }
+  MC2x2Base<ValType>& operator*=(ValType rhs) {
+    Matrix2x2::ScalarMultiply(_values, rhs);
+    return *this;
+  }
+  MC2x2Base<ValType> operator*(ValType rhs) const {
+    MC2x2Base<ValType> dest(*this);
+    Matrix2x2::ScalarMultiply(dest._values, rhs);
+    return dest;
+  }
+  MC2x2Base<ValType>& operator/=(ValType rhs) {
+    Matrix2x2::ScalarMultiply(_values, 1.0 / rhs);
+    return *this;
+  }
+  const std::complex<ValType>& operator[](size_t index) const {
+    return _values[index];
+  }
+  std::complex<ValType>& operator[](size_t index) { return _values[index]; }
+  const ValType& IndexReal(size_t index) const {
+    return reinterpret_cast<const ValType(&)[2]>(_values[index / 2])[index % 2];
+  }
+  ValType& IndexReal(size_t index) {
+    return reinterpret_cast<ValType(&)[2]>(_values[index / 2])[index % 2];
+  }
+  static MC2x2Base<ValType> Zero() {
+    return MC2x2Base<ValType>(0.0, 0.0, 0.0, 0.0);
+  }
+  static MC2x2Base<ValType> Unity() { return MC2x2Base(1.0, 0.0, 0.0, 1.0); }
+  static MC2x2Base<ValType> NaN() {
+    return MC2x2Base<ValType>(
+        std::complex<ValType>(std::numeric_limits<ValType>::quiet_NaN(),
+                              std::numeric_limits<ValType>::quiet_NaN()),
+        std::complex<ValType>(std::numeric_limits<ValType>::quiet_NaN(),
+                              std::numeric_limits<ValType>::quiet_NaN()),
+        std::complex<ValType>(std::numeric_limits<ValType>::quiet_NaN(),
+                              std::numeric_limits<ValType>::quiet_NaN()),
+        std::complex<ValType>(std::numeric_limits<ValType>::quiet_NaN(),
+                              std::numeric_limits<ValType>::quiet_NaN()));
+  }
+  std::complex<ValType>* Data() { return _values; }
+  const std::complex<ValType>* Data() const { return _values; }
+
+  void AssignTo(std::complex<ValType>* destination) const {
+    Matrix2x2::Assign(destination, _values);
+  }
+
+  Vector4 Vec() const {
+    return Vector4(_values[0], _values[2], _values[1], _values[3]);
+  }
+
+  MC2x2Base<ValType> Multiply(const MC2x2Base<ValType>& rhs) const {
+    MC2x2Base<ValType> dest;
+    Matrix2x2::ATimesB(dest._values, _values, rhs._values);
+    return dest;
+  }
+  MC2x2Base<ValType> MultiplyHerm(const MC2x2Base<ValType>& rhs) const {
+    MC2x2Base dest;
+    Matrix2x2::ATimesHermB(dest._values, _values, rhs._values);
+    return dest;
+  }
+  MC2x2Base<ValType> HermThenMultiply(const MC2x2Base<ValType>& rhs) const {
+    MC2x2Base<ValType> dest;
+    Matrix2x2::HermATimesB(dest._values, _values, rhs._values);
+    return dest;
+  }
+  MC2x2Base<ValType> HermThenMultiplyHerm(const MC2x2Base<ValType>& rhs) const {
+    MC2x2Base<ValType> dest;
+    Matrix2x2::HermATimesHermB(dest._values, _values, rhs._values);
+    return dest;
+  }
+  void AddWithFactorAndAssign(const MC2x2Base<ValType>& rhs, ValType factor) {
+    Matrix2x2::MultiplyAdd(_values, rhs._values, factor);
+  }
+  MC2x2Base<ValType> Transpose() const {
+    return MC2x2Base(_values[0], _values[2], _values[1], _values[3]);
+  }
+  MC2x2Base<ValType> HermTranspose() const {
+    return MC2x2Base(std::conj(_values[0]), std::conj(_values[2]),
+                     std::conj(_values[1]), std::conj(_values[3]));
+  }
+  bool Invert() { return Matrix2x2::Invert(_values); }
+  static void ATimesB(MC2x2Base<ValType>& dest, const MC2x2Base<ValType>& lhs,
+                      const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::ATimesB(dest._values, lhs._values, rhs._values);
+  }
+  static void ATimesB(std::complex<ValType>* dest,
+                      const MC2x2Base<ValType>& lhs,
+                      const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::ATimesB(dest, lhs._values, rhs._values);
+  }
+  static void ATimesHermB(MC2x2Base<ValType>& dest,
+                          const MC2x2Base<ValType>& lhs,
+                          const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::ATimesHermB(dest._values, lhs._values, rhs._values);
+  }
+  static void HermATimesB(MC2x2Base<ValType>& dest,
+                          const MC2x2Base<ValType>& lhs,
+                          const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::HermATimesB(dest._values, lhs._values, rhs._values);
+  }
+  static void HermATimesHermB(MC2x2Base<ValType>& dest,
+                              const MC2x2Base<ValType>& lhs,
+                              const MC2x2Base<ValType>& rhs) {
+    Matrix2x2::HermATimesHermB(dest._values, lhs._values, rhs._values);
+  }
+  std::string ToString() const {
+    std::stringstream str;
+    str << _values[0] << ", " << _values[1] << "; " << _values[2] << ", "
+        << _values[3];
+    return str.str();
+  }
+  void CopyValues(std::complex<ValType>* values) const {
+    Matrix2x2::Assign(values, _values);
+  }
+  void EigenValues(std::complex<ValType>& e1, std::complex<ValType>& e2) const {
+    Matrix2x2::EigenValues(_values, e1, e2);
+  }
+  bool IsFinite() const {
+    return std::isfinite(_values[0].real()) &&
+           std::isfinite(_values[0].imag()) &&
+           std::isfinite(_values[1].real()) &&
+           std::isfinite(_values[1].imag()) &&
+           std::isfinite(_values[2].real()) &&
+           std::isfinite(_values[2].imag()) &&
+           std::isfinite(_values[3].real()) && std::isfinite(_values[3].imag());
+  }
+  /**
+   * Calculates L, the lower triangle of the Cholesky decomposition, such that
+   * L L^H = M.
+   */
+  bool Cholesky() { return Matrix2x2::Cholesky(_values); }
+  bool CheckedCholesky() { return Matrix2x2::CheckedCholesky(_values); }
+  void UncheckedCholesky() { Matrix2x2::UncheckedCholesky(_values); }
+  /**
+   * Decompose a Hermitian matrix X into A A^H such that
+   *   X = A A^H = U D D^H U^H
+   *   with A = U D
+   * where D D^H = E is a diagonal matrix
+   *       with the eigen values of X, and U contains the eigen vectors.
+   */
+  MC2x2Base<ValType> DecomposeHermitianEigenvalue() {
+    std::complex<ValType> e1, e2, vec1[2], vec2[2];
+    Matrix2x2::EigenValuesAndVectors(_values, e1, e2, vec1, vec2);
+    ValType v1norm = std::norm(vec1[0]) + std::norm(vec1[1]);
+    vec1[0] /= std::sqrt(v1norm);
+    vec1[1] /= std::sqrt(v1norm);
+    ValType v2norm = std::norm(vec2[0]) + std::norm(vec2[1]);
+    vec2[0] /= std::sqrt(v2norm);
+    vec2[1] /= std::sqrt(v2norm);
+
+    return MC2x2Base<ValType>(
+        vec1[0] * std::sqrt(e1.real()), vec2[0] * std::sqrt(e2.real()),
+        vec1[1] * std::sqrt(e1.real()), vec2[1] * std::sqrt(e2.real()));
+  }
+
+ private:
+  std::complex<ValType> _values[4];
+};
+
+using MC2x2 = MC2x2Base<double>;
+using MC2x2F = MC2x2Base<float>;
+
+}  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/matrix4x4.h
@@ -0,0 +1,179 @@
+#ifndef MATRIX_4X4_H
+#define MATRIX_4X4_H
+
+#include <complex>
+#include <string>
+#include <sstream>
+#include <stdexcept>
+
+#include <aocommon/matrix2x2.h>
+
+namespace aocommon {
+
+class Matrix4x4 {
+ public:
+  Matrix4x4() {}
+
+  Matrix4x4(std::initializer_list<std::complex<double>> list) {
+    if (list.size() != 16)
+      throw std::runtime_error(
+          "Matrix4x4 needs to be initialized with 16 items");
+    size_t index = 0;
+    for (const std::complex<double>& el : list) {
+      _data[index] = el;
+      ++index;
+    }
+  }
+
+  static Matrix4x4 Zero() { return Matrix4x4(); }
+
+  static Matrix4x4 Unit() {
+    Matrix4x4 unit;
+    unit[0] = 1.0;
+    unit[5] = 1.0;
+    unit[10] = 1.0;
+    unit[15] = 1.0;
+    return unit;
+  }
+
+  Matrix4x4 operator+(const Matrix4x4& rhs) const {
+    Matrix4x4 result;
+    for (size_t i = 0; i != 16; ++i) result[i] = this->_data[i] + rhs._data[i];
+    return result;
+  }
+
+  Matrix4x4& operator+=(const Matrix4x4& rhs) {
+    for (size_t i = 0; i != 16; ++i) _data[i] += rhs._data[i];
+    return *this;
+  }
+
+  Matrix4x4 operator*(const std::complex<double>& rhs) const {
+    Matrix4x4 m;
+    for (size_t i = 0; i != 16; ++i) m[i] = _data[i] * rhs;
+    return m;
+  }
+
+  Vector4 operator*(const Vector4& rhs) const {
+    Vector4 v(_data[0] * rhs[0], _data[4] * rhs[0], _data[8] * rhs[0],
+              _data[12] * rhs[0]);
+    for (size_t i = 1; i != 4; ++i) {
+      v[0] += _data[i] * rhs[i];
+      v[1] += _data[i + 4] * rhs[i];
+      v[2] += _data[i + 8] * rhs[i];
+      v[3] += _data[i + 12] * rhs[i];
+    }
+    return v;
+  }
+
+  bool Invert() {
+    std::complex<double> inv[16];
+    const std::complex<double>* m = _data;
+
+    inv[0] = m[5] * m[10] * m[15] - m[5] * m[11] * m[14] - m[9] * m[6] * m[15] +
+             m[9] * m[7] * m[14] + m[13] * m[6] * m[11] - m[13] * m[7] * m[10];
+
+    inv[4] = -m[4] * m[10] * m[15] + m[4] * m[11] * m[14] +
+             m[8] * m[6] * m[15] - m[8] * m[7] * m[14] - m[12] * m[6] * m[11] +
+             m[12] * m[7] * m[10];
+
+    inv[8] = m[4] * m[9] * m[15] - m[4] * m[11] * m[13] - m[8] * m[5] * m[15] +
+             m[8] * m[7] * m[13] + m[12] * m[5] * m[11] - m[12] * m[7] * m[9];
+
+    inv[12] = -m[4] * m[9] * m[14] + m[4] * m[10] * m[13] +
+              m[8] * m[5] * m[14] - m[8] * m[6] * m[13] - m[12] * m[5] * m[10] +
+              m[12] * m[6] * m[9];
+
+    inv[1] = -m[1] * m[10] * m[15] + m[1] * m[11] * m[14] +
+             m[9] * m[2] * m[15] - m[9] * m[3] * m[14] - m[13] * m[2] * m[11] +
+             m[13] * m[3] * m[10];
+
+    inv[5] = m[0] * m[10] * m[15] - m[0] * m[11] * m[14] - m[8] * m[2] * m[15] +
+             m[8] * m[3] * m[14] + m[12] * m[2] * m[11] - m[12] * m[3] * m[10];
+
+    inv[9] = -m[0] * m[9] * m[15] + m[0] * m[11] * m[13] + m[8] * m[1] * m[15] -
+             m[8] * m[3] * m[13] - m[12] * m[1] * m[11] + m[12] * m[3] * m[9];
+
+    inv[13] = m[0] * m[9] * m[14] - m[0] * m[10] * m[13] - m[8] * m[1] * m[14] +
+              m[8] * m[2] * m[13] + m[12] * m[1] * m[10] - m[12] * m[2] * m[9];
+
+    inv[2] = m[1] * m[6] * m[15] - m[1] * m[7] * m[14] - m[5] * m[2] * m[15] +
+             m[5] * m[3] * m[14] + m[13] * m[2] * m[7] - m[13] * m[3] * m[6];
+
+    inv[6] = -m[0] * m[6] * m[15] + m[0] * m[7] * m[14] + m[4] * m[2] * m[15] -
+             m[4] * m[3] * m[14] - m[12] * m[2] * m[7] + m[12] * m[3] * m[6];
+
+    inv[10] = m[0] * m[5] * m[15] - m[0] * m[7] * m[13] - m[4] * m[1] * m[15] +
+              m[4] * m[3] * m[13] + m[12] * m[1] * m[7] - m[12] * m[3] * m[5];
+
+    inv[14] = -m[0] * m[5] * m[14] + m[0] * m[6] * m[13] + m[4] * m[1] * m[14] -
+              m[4] * m[2] * m[13] - m[12] * m[1] * m[6] + m[12] * m[2] * m[5];
+
+    inv[3] = -m[1] * m[6] * m[11] + m[1] * m[7] * m[10] + m[5] * m[2] * m[11] -
+             m[5] * m[3] * m[10] - m[9] * m[2] * m[7] + m[9] * m[3] * m[6];
+
+    inv[7] = m[0] * m[6] * m[11] - m[0] * m[7] * m[10] - m[4] * m[2] * m[11] +
+             m[4] * m[3] * m[10] + m[8] * m[2] * m[7] - m[8] * m[3] * m[6];
+
+    inv[11] = -m[0] * m[5] * m[11] + m[0] * m[7] * m[9] + m[4] * m[1] * m[11] -
+              m[4] * m[3] * m[9] - m[8] * m[1] * m[7] + m[8] * m[3] * m[5];
+
+    inv[15] = m[0] * m[5] * m[10] - m[0] * m[6] * m[9] - m[4] * m[1] * m[10] +
+              m[4] * m[2] * m[9] + m[8] * m[1] * m[6] - m[8] * m[2] * m[5];
+
+    std::complex<double> det =
+        m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];
+
+    if (det == 0.0) return false;
+
+    det = 1.0 / det;
+
+    for (size_t i = 0; i < 16; i++) _data[i] = inv[i] * det;
+
+    return true;
+  }
+
+  std::complex<double>& operator[](size_t i) { return _data[i]; }
+
+  const std::complex<double>& operator[](size_t i) const { return _data[i]; }
+
+  double Norm() const {
+    double n = 0.0;
+    for (size_t i = 0; i != 16; ++i) {
+      n += std::norm(_data[i]);
+    }
+    return n;
+  }
+
+  std::string String() const {
+    std::ostringstream str;
+    for (size_t y = 0; y != 4; ++y) {
+      for (size_t x = 0; x != 3; ++x) {
+        str << _data[x + y * 4] << '\t';
+      }
+      str << _data[3 + y * 4] << '\n';
+    }
+    return str.str();
+  }
+
+  static Matrix4x4 KroneckerProduct(const MC2x2& veca, const MC2x2& vecb) {
+    Matrix4x4 result;
+    const size_t posa[4] = {0, 2, 8, 10};
+    for (size_t i = 0; i != 4; ++i) {
+      result[posa[i]] = veca[i] * vecb[0];
+      result[posa[i] + 1] = veca[i] * vecb[1];
+      result[posa[i] + 4] = veca[i] * vecb[2];
+      result[posa[i] + 5] = veca[i] * vecb[3];
+    }
+    return result;
+  }
+
+ private:
+  std::complex<double> _data[16];
+};
+
+// typedef Matrix4x4<std::complex<double>> MC4x4;
+typedef Matrix4x4 MC4x4;
+
+}  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/parallelfor.h
@@ -0,0 +1,136 @@
+#ifndef PARALLEL_FOR_H
+#define PARALLEL_FOR_H
+
+#include "barrier.h"
+
+#include <atomic>
+#include <condition_variable>
+#include <cstring>
+#include <mutex>
+#include <thread>
+#include <vector>
+
+#include <sched.h>
+
+namespace aocommon {
+
+template <typename Iter>
+class ParallelFor {
+ public:
+  ParallelFor(size_t nThreads)
+      : _nThreads(nThreads),
+        _barrier(nThreads, [&]() { _hasTasks = false; }),
+        _stop(false),
+        _hasTasks(false) {}
+
+  ~ParallelFor() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    if (!_threads.empty()) {
+      _stop = true;
+      _hasTasks = true;
+      _conditionChanged.notify_all();
+      lock.unlock();
+      for (std::thread &thr : _threads) thr.join();
+    }
+  }
+
+  /**
+   * Iteratively call a function in parallel.
+   *
+   * The function is expected to accept two size_t parameters, the loop
+   * index and the thread id, e.g.:
+   *   void loopFunction(size_t iteration, size_t threadID);
+   * It is called (end-start) times.
+   *
+   * This function is very similar to ThreadPool::For(), but does not
+   * support recursion. For non-recursive loop, this function will be
+   * faster.
+   */
+  void Run(Iter start, Iter end, std::function<void(Iter, size_t)> function) {
+    if (end == start + 1) {
+      function(start, 0);
+    } else {
+      if (_threads.empty()) startThreads();
+      std::unique_lock<std::mutex> lock(_mutex);
+      _current = start;
+      _end = end;
+      _loopFunction = std::move(function);
+      _hasTasks = true;
+      _conditionChanged.notify_all();
+      lock.unlock();
+      loop(0);
+      _barrier.wait();
+    }
+  }
+
+  size_t NThreads() const { return _nThreads; }
+
+  /**
+   * This method is only allowed to be called before Run() is
+   * called.
+   */
+  void SetNThreads(size_t nThreads) {
+    if (_threads.empty()) {
+      _nThreads = nThreads;
+      _barrier = Barrier(nThreads, [&]() { _hasTasks = false; });
+    } else {
+      throw std::runtime_error("Can not set NThreads after calling Run()");
+    }
+  }
+
+ private:
+  ParallelFor(const ParallelFor &) = delete;
+
+  void loop(size_t thread) {
+    Iter iter;
+    while (next(iter)) {
+      _loopFunction(iter, thread);
+    }
+  }
+
+  void run(size_t thread) {
+    waitForTasks();
+    while (!_stop) {
+      loop(thread);
+      _barrier.wait();
+      waitForTasks();
+    }
+  }
+
+  bool next(Iter &iter) {
+    std::lock_guard<std::mutex> lock(_mutex);
+    if (_current == _end)
+      return false;
+    else {
+      iter = _current;
+      ++_current;
+      return true;
+    }
+  }
+
+  void waitForTasks() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    while (!_hasTasks) _conditionChanged.wait(lock);
+  }
+
+  void startThreads() {
+    if (_nThreads > 1) {
+      _threads.reserve(_nThreads - 1);
+      for (unsigned t = 1; t != _nThreads; ++t)
+        _threads.emplace_back(&ParallelFor::run, this, t);
+    }
+  }
+
+  Iter _current, _end;
+  std::mutex _mutex;
+  size_t _nThreads;
+  Barrier _barrier;
+  std::atomic<bool> _stop;
+  bool _hasTasks;
+  std::condition_variable _conditionChanged;
+  std::vector<std::thread> _threads;
+  std::function<void(size_t, size_t)> _loopFunction;
+};
+}  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/polarization.h
@@ -0,0 +1,518 @@
+#ifndef POLARIZATION_H
+#define POLARIZATION_H
+
+#include <complex>
+#include <stdexcept>
+#include <set>
+#include <vector>
+
+namespace aocommon {
+
+/**
+ * Class for various simple polarization related values.
+ *
+ * The visibility relations for converting polarizations are:
+ *
+ *   RR = I + V  ;   I = (RR + LL)/2
+ *   RL = Q + iU ;   Q = (RL + LR)/2
+ *   LR = Q - iU ;   U = -i (RL - LR)/2
+ *   LL = I - V  ;   V = (RR - LL)/2
+ *
+ *   XX = I + Q  ;   I = (XX + YY)/2
+ *   XY = U + iV ;   Q = (XX - YY)/2
+ *   YX = U - iV ;   U = (XY + YX)/2
+ *   YY = I - Q  ;   V = -i(XY - YX)/2
+ *
+ * These definitions assume that 'X' and 'Y' are labelled as they are in
+ * CASA measurement sets: X is North-South.
+ *
+ * Note that uv-fits files have the polarizations labelled such that X
+ * is East-West, confusingly. We have also observed that at present (2016)
+ * CASA's importuvfits does not swap the polarizations, hence Measurement
+ * Sets exist that have the polarizations labelled wrong.
+ * The IEEE definition is to have X be N-S.
+ * See also: http://adsabs.harvard.edu/abs/1996A%26AS..117..161H
+ */
+class Polarization {
+ public:
+  enum PolarizationEnum {
+    StokesI,
+    StokesQ,
+    StokesU,
+    StokesV,
+    RR,
+    RL,
+    LR,
+    LL,
+    XX,
+    XY,
+    YX,
+    YY,
+    /**
+     * Instrumental is a special value representing that four polarizations are
+     * stored, and these are the 'raw' measurement set polarizations. It is used
+     * as a special value that e.g. can be passed to a MSProvider, which would
+     * mean all values are gridded at once, as required for an a-term correcting
+     * gridder.
+     */
+    Instrumental
+  };
+
+  static size_t TypeToIndex(enum PolarizationEnum polarization,
+                            size_t polCountInSet) {
+    switch (polCountInSet) {
+      case 1:
+        if (polarization != StokesI)
+          throw std::runtime_error(
+              "TypeTo4PolIndex(): can't convert given polarization to index");
+        else
+          return 0;
+      case 2:
+        switch (polarization) {
+          case XX:
+            return 0;
+          case YY:
+            return 1;
+          default:
+            throw std::runtime_error(
+                "TypeTo4PolIndex(): can't convert given polarization to index");
+        }
+      case 4:
+        switch (polarization) {
+          case XX:
+            return 0;
+          case XY:
+            return 1;
+          case YX:
+            return 2;
+          case YY:
+            return 3;
+          default:
+            throw std::runtime_error(
+                "TypeTo4PolIndex(): can't convert given polarization to index");
+        }
+      default:
+        throw std::runtime_error(
+            "TypeTo4PolIndex(): can't convert given polarization to index");
+    }
+  }
+
+  static enum PolarizationEnum AipsIndexToEnum(int index) {
+    switch (index) {
+      case 1:
+        return StokesI;
+      case 2:
+        return StokesQ;
+      case 3:
+        return StokesU;
+      case 4:
+        return StokesV;
+      case 5:
+        return RR;
+      case 6:
+        return RL;
+      case 7:
+        return LR;
+      case 8:
+        return LL;
+      case 9:
+        return XX;
+      case 10:
+        return XY;
+      case 11:
+        return YX;
+      case 12:
+        return YY;
+      default:
+        throw std::runtime_error(
+            "AipsIndexToEnum(): unknown aips polarization index");
+    }
+  }
+
+  static int EnumToAipsIndex(enum PolarizationEnum pol) {
+    switch (pol) {
+      case StokesI:
+        return 1;
+      case StokesQ:
+        return 2;
+      case StokesU:
+        return 3;
+      case StokesV:
+        return 4;
+      case RR:
+        return 5;
+      case RL:
+        return 6;
+      case LR:
+        return 7;
+      case LL:
+        return 8;
+      case XX:
+        return 9;
+      case XY:
+        return 10;
+      case YX:
+        return 11;
+      case YY:
+        return 12;
+      default:
+        throw std::runtime_error("EnumToAipsIndex(): unknown polarization");
+    }
+  }
+
+  static bool TypeToIndex(enum PolarizationEnum polarization,
+                          const std::vector<PolarizationEnum>& polList,
+                          size_t& index) {
+    for (size_t i = 0; i != polList.size(); ++i) {
+      if (polList[i] == polarization) {
+        index = i;
+        return true;
+      }
+    }
+    return false;
+  }
+
+  template <typename Range>
+  static bool TypeToIndex(enum PolarizationEnum polarization,
+                          const Range& polList, size_t& index) {
+    size_t curIndex = 0;
+    for (typename Range::const_iterator i = polList.begin(); i != polList.end();
+         ++i, ++curIndex) {
+      if (*i == polarization) {
+        index = curIndex;
+        return true;
+      }
+    }
+    return false;
+  }
+
+  static size_t StokesToIndex(enum PolarizationEnum polarization) {
+    switch (polarization) {
+      default:
+      case StokesI:
+        return 0;
+      case StokesQ:
+        return 1;
+      case StokesU:
+        return 2;
+      case StokesV:
+        return 3;
+    }
+  }
+
+  static PolarizationEnum IndexToStokes(size_t index) {
+    const static PolarizationEnum arr[4] = {StokesI, StokesQ, StokesU, StokesV};
+    return arr[index];
+  }
+
+  static bool IsStokes(enum PolarizationEnum polarization) {
+    return polarization == StokesI || polarization == StokesQ ||
+           polarization == StokesU || polarization == StokesV;
+  }
+
+  static size_t TypeTo4PolIndex(enum PolarizationEnum polarization) {
+    switch (polarization) {
+      case XX:
+        return 0;
+      case XY:
+        return 1;
+      case YX:
+        return 2;
+      case YY:
+        return 3;
+      default:
+        throw std::runtime_error(
+            "TypeTo4PolIndex(): can't convert given polarization to index");
+    }
+  }
+
+  static std::string TypeToShortString(enum PolarizationEnum polarization) {
+    switch (polarization) {
+      case XX:
+        return "XX";
+      case XY:
+        return "XY";
+      case YX:
+        return "YX";
+      case YY:
+        return "YY";
+      case StokesI:
+        return "I";
+      case StokesQ:
+        return "Q";
+      case StokesU:
+        return "U";
+      case StokesV:
+        return "V";
+      case RR:
+        return "RR";
+      case RL:
+        return "RL";
+      case LR:
+        return "LR";
+      case LL:
+        return "LL";
+      case Instrumental:
+        return "instr";
+      default:
+        return "";
+    }
+  }
+
+  static std::string TypeToFullString(enum PolarizationEnum polarization) {
+    switch (polarization) {
+      case XX:
+        return "XX";
+      case XY:
+        return "XY";
+      case YX:
+        return "YX";
+      case YY:
+        return "YY";
+      case StokesI:
+        return "Stokes I";
+      case StokesQ:
+        return "Stokes Q";
+      case StokesU:
+        return "Stokes U";
+      case StokesV:
+        return "Stokes V";
+      case RR:
+        return "RR";
+      case RL:
+        return "RL";
+      case LR:
+        return "LR";
+      case LL:
+        return "LL";
+      case Instrumental:
+        return "instrumental";
+      default:
+        return "Unknown polarization";
+    }
+  }
+
+  static bool HasFullPolarization(
+      const std::set<PolarizationEnum>& polarizations) {
+    return HasFullLinearPolarization(polarizations) ||
+           HasFullStokesPolarization(polarizations) ||
+           (polarizations.count(RR) > 0 && polarizations.count(RL) > 0 &&
+            polarizations.count(LR) > 0 && polarizations.count(LL) > 0);
+  }
+
+  static bool HasFullLinearPolarization(
+      const std::set<PolarizationEnum>& polarizations) {
+    return (polarizations.count(XX) > 0 && polarizations.count(XY) > 0 &&
+            polarizations.count(YX) > 0 && polarizations.count(YY) > 0);
+  }
+
+  static bool HasFullCircularPolarization(
+      const std::set<PolarizationEnum>& polarizations) {
+    return (polarizations.count(LL) > 0 && polarizations.count(LR) > 0 &&
+            polarizations.count(RL) > 0 && polarizations.count(RR) > 0);
+  }
+
+  static bool HasFullStokesPolarization(
+      const std::set<PolarizationEnum>& polarizations) {
+    return (
+        polarizations.count(StokesI) > 0 && polarizations.count(StokesQ) > 0 &&
+        polarizations.count(StokesU) > 0 && polarizations.count(StokesV) > 0);
+  }
+
+  static bool HasDualPolarization(
+      const std::set<PolarizationEnum>& polarizations) {
+    return HasDualLinearPolarization(polarizations) ||
+           (polarizations.count(RR) > 0 && polarizations.count(LL) > 0);
+  }
+
+  static bool HasDualLinearPolarization(
+      const std::set<PolarizationEnum>& polarizations) {
+    return (polarizations.count(XX) > 0 && polarizations.count(YY) > 0);
+  }
+
+  static bool IsComplex(PolarizationEnum polarization) {
+    return polarization == XY || polarization == YX;
+  }
+
+  static PolarizationEnum ParseString(const std::string& str) {
+    if (str == "XX")
+      return XX;
+    else if (str == "XY")
+      return XY;
+    else if (str == "YX")
+      return YX;
+    else if (str == "YY")
+      return YY;
+    else if (str == "I")
+      return StokesI;
+    else if (str == "Q")
+      return StokesQ;
+    else if (str == "U")
+      return StokesU;
+    else if (str == "V")
+      return StokesV;
+    else if (str == "RR")
+      return RR;
+    else if (str == "RL")
+      return RL;
+    else if (str == "LR")
+      return LR;
+    else if (str == "LL")
+      return LL;
+    else
+      throw std::runtime_error(
+          std::string("Could not parse polarization string: ") + str);
+  }
+
+  static std::set<PolarizationEnum> ParseList(const std::string& listStr) {
+    std::set<PolarizationEnum> list;
+    enum {
+      StartSt,
+      GotXSt,
+      GotYSt,
+      GotLSt,
+      GotRSt,
+      GotSeperatorSt
+    } state = StartSt;
+    for (std::string::const_iterator i = listStr.begin(); i != listStr.end();
+         ++i) {
+      char c = (*i >= 'a' && *i <= 'z') ? *i - ('a' - 'A') : *i;
+      switch (c) {
+        case 'X':
+          if (state == StartSt || state == GotSeperatorSt)
+            state = GotXSt;
+          else {
+            if (state == GotXSt)
+              list.insert(XX);
+            else if (state == GotYSt)
+              list.insert(YX);
+            else
+              throw std::runtime_error(
+                  "Invalid polarization list: parse error near 'X'");
+            state = StartSt;
+          }
+          break;
+        case 'Y':
+          if (state == StartSt || state == GotSeperatorSt)
+            state = GotYSt;
+          else {
+            if (state == GotXSt)
+              list.insert(XY);
+            else if (state == GotYSt)
+              list.insert(YY);
+            else
+              throw std::runtime_error(
+                  "Invalid polarization list: parse error near 'Y'");
+            state = StartSt;
+          }
+          break;
+        case 'R':
+          if (state == StartSt || state == GotSeperatorSt)
+            state = GotRSt;
+          else {
+            if (state == GotRSt)
+              list.insert(RR);
+            else if (state == GotLSt)
+              list.insert(LR);
+            else
+              throw std::runtime_error(
+                  "Invalid polarization list: parse error near 'R'");
+            state = StartSt;
+          }
+          break;
+        case 'L':
+          if (state == StartSt || state == GotSeperatorSt)
+            state = GotLSt;
+          else {
+            if (state == GotRSt)
+              list.insert(RL);
+            else if (state == GotLSt)
+              list.insert(LL);
+            else
+              throw std::runtime_error(
+                  "Invalid polarization list: parse error near 'L'");
+            state = StartSt;
+          }
+          break;
+        case 'I':
+          if (state == StartSt || state == GotSeperatorSt)
+            list.insert(StokesI);
+          else
+            throw std::runtime_error(
+                "Invalid polarization list: parse error near 'I'");
+          state = StartSt;
+          break;
+        case 'Q':
+          if (state == StartSt || state == GotSeperatorSt)
+            list.insert(StokesQ);
+          else
+            throw std::runtime_error(
+                "Invalid polarization list: parse error near 'Q'");
+          state = StartSt;
+          break;
+        case 'U':
+          if (state == StartSt || state == GotSeperatorSt)
+            list.insert(StokesU);
+          else
+            throw std::runtime_error(
+                "Invalid polarization list: parse error near 'U'");
+          state = StartSt;
+          break;
+        case 'V':
+          if (state == StartSt || state == GotSeperatorSt)
+            list.insert(StokesV);
+          else
+            throw std::runtime_error(
+                "Invalid polarization list: parse error near 'V'");
+          state = StartSt;
+          break;
+        case ',':
+        case ' ':
+        case '/':
+          if (state == StartSt)
+            state = GotSeperatorSt;
+          else
+            throw std::runtime_error(
+                "Invalid polarization list: parse error near seperator");
+      }
+    }
+    if (state != StartSt)
+      throw std::runtime_error(
+          "Invalid polarization list: parse error near string end");
+    return list;
+  }
+
+  template <typename NumType>
+  static void LinearToStokes(const std::complex<NumType>* linear,
+                             NumType* stokes) {
+    // Note comments about X and Y at the top of this file!
+    stokes[0] = 0.5 * (linear[0].real() + linear[3].real());
+    stokes[1] = 0.5 * (linear[0].real() - linear[3].real());
+    stokes[2] = 0.5 * (linear[1].real() + linear[2].real());
+    stokes[3] = 0.5 * (linear[1].imag() - linear[2].imag());
+  }
+
+  template <typename NumType>
+  static void StokesToLinear(const NumType* stokes,
+                             std::complex<NumType>* linear) {
+    linear[0] = stokes[0] + stokes[1];
+    linear[1] = std::complex<NumType>(stokes[2], stokes[3]);
+    linear[2] = std::complex<NumType>(stokes[2], -stokes[3]);
+    linear[3] = stokes[0] - stokes[1];
+  }
+
+  template <typename NumType>
+  static void CircularToStokes(const std::complex<NumType>* circular,
+                               NumType* stokes) {
+    stokes[0] = (circular[0] + circular[3]).real() * 0.5;
+    stokes[1] = (circular[1] + circular[2]).real() * 0.5;
+    stokes[2] = (circular[1] - circular[2]).imag() * 0.5;
+    stokes[3] = (circular[0] - circular[3]).real() * 0.5;
+  }
+};
+
+typedef Polarization::PolarizationEnum PolarizationEnum;
+
+}  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/radeccoord.h
@@ -0,0 +1,271 @@
+#ifndef RADECCOORD_H
+#define RADECCOORD_H
+
+#include <string>
+#include <sstream>
+#include <stdexcept>
+#include <cstdlib>
+#include <cmath>
+
+#ifndef M_PIl
+#define M_PIl 3.141592653589793238462643383279502884L
+#endif
+
+namespace aocommon {
+class RaDecCoord {
+ private:
+  static bool isRASeparator(char c) { return c == ':' || c == ' '; }
+  static bool isDecSeparator(char c) { return c == '.' || c == ' '; }
+
+ public:
+  static long double ParseRA(const std::string& str) {
+    char* cstr;
+    bool sign = false;
+    for (size_t i = 0; i != str.size(); ++i) {
+      if (str[i] == '-') {
+        sign = true;
+        break;
+      } else if (str[i] != ' ') {
+        sign = false;
+        break;
+      }
+    }
+    long double secs = 0.0, mins = 0.0, hrs = strtol(str.c_str(), &cstr, 10);
+    // Parse format '00h00m00.0s'
+    if (*cstr == 'h') {
+      ++cstr;
+      mins = strtol(cstr, &cstr, 10);
+      if (*cstr == 'm') {
+        ++cstr;
+        secs = strtold(cstr, &cstr);
+        if (*cstr == 's')
+          ++cstr;
+        else
+          throw std::runtime_error("Missing 's'");
+      } else
+        throw std::runtime_error("Missing 'm'");
+    }
+    // Parse format '00:00:00.0'
+    else if (isRASeparator(*cstr)) {
+      ++cstr;
+      mins = strtol(cstr, &cstr, 10);
+      if (isRASeparator(*cstr)) {
+        ++cstr;
+        secs = strtold(cstr, &cstr);
+      } else
+        throw std::runtime_error("Missing ':' after minutes");
+    } else
+      throw std::runtime_error("Missing 'h' or ':' in string '" + str + "'");
+    if (*cstr != 0)
+      throw std::runtime_error("Could not parse RA '" + str +
+                               "' (string contains more tokens than expected)");
+    if (sign)
+      return (hrs / 24.0 - mins / (24.0 * 60.0) - secs / (24.0 * 60.0 * 60.0)) *
+             2.0 * M_PIl;
+    else
+      return (hrs / 24.0 + mins / (24.0 * 60.0) + secs / (24.0 * 60.0 * 60.0)) *
+             2.0 * M_PIl;
+  }
+
+  static long double ParseDec(const std::string& str) {
+    char* cstr;
+    bool sign = false;
+    for (size_t i = 0; i != str.size(); ++i) {
+      if (str[i] == '-') {
+        sign = true;
+        break;
+      } else if (str[i] != ' ') {
+        sign = false;
+        break;
+      }
+    }
+    long double secs = 0.0, mins = 0.0, degs = strtol(str.c_str(), &cstr, 10);
+    // Parse format '00d00m00.0s'
+    if (*cstr == 'd') {
+      ++cstr;
+      mins = strtol(cstr, &cstr, 10);
+      if (*cstr == 'm') {
+        ++cstr;
+        secs = strtold(cstr, &cstr);
+        if (*cstr == 's')
+          ++cstr;
+        else
+          throw std::runtime_error("Missing 's'");
+      } else
+        throw std::runtime_error("Missing 'm'");
+    }
+    // Parse format '00.00.00.0'
+    else if (isDecSeparator(*cstr)) {
+      ++cstr;
+      mins = strtol(cstr, &cstr, 10);
+      if (isDecSeparator(*cstr)) {
+        ++cstr;
+        secs = strtold(cstr, &cstr);
+      } else
+        throw std::runtime_error("Missing '.' after minutes");
+    } else
+      throw std::runtime_error("Missing 'd' or '.' after degrees");
+    if (*cstr != 0)
+      throw std::runtime_error(
+          "Could not parse Dec (string contains more tokens than expected)");
+    else if (sign)
+      return (degs / 360.0 - mins / (360.0 * 60.0) -
+              secs / (360.0 * 60.0 * 60.0)) *
+             2.0 * M_PIl;
+    else
+      return (degs / 360.0 + mins / (360.0 * 60.0) +
+              secs / (360.0 * 60.0 * 60.0)) *
+             2.0 * M_PIl;
+  }
+
+  static std::string RAToString(long double ra) {
+    const long double partsPerHour = 60.0L * 60.0L * 1000.0L;
+    long double hrs = fmodl(ra * (12.0L / M_PIl), 24.0L);
+    hrs = roundl(hrs * partsPerHour) / partsPerHour;
+    std::stringstream s;
+    if (hrs < 0.0L) {
+      hrs += 24.0L;
+    }
+    hrs = (roundl(hrs * partsPerHour) + 0.5) / partsPerHour;
+    int hrsInt = int(floorl(hrs)),
+        minInt = int(floorl(fmodl(hrs, 1.0L) * 60.0L)),
+        secInt = int(floorl(fmodl(hrs * 60.0L, 1.0L) * (60.0L))),
+        subSecInt = int(floorl(fmodl(hrs * (60.0L * 60.0L), 1.0L) * (1000.0L)));
+    s << (char)((hrsInt / 10) + '0') << (char)((hrsInt % 10) + '0') << 'h'
+      << (char)((minInt / 10) + '0') << (char)((minInt % 10) + '0') << 'm'
+      << (char)((secInt / 10) + '0') << (char)((secInt % 10) + '0');
+    s << '.' << (char)(subSecInt / 100 + '0');
+    if (subSecInt % 100 != 0) {
+      s << (char)((subSecInt % 100) / 10 + '0');
+      if (subSecInt % 10 != 0) s << (char)((subSecInt % 10) + '0');
+    }
+    s << 's';
+    return s.str();
+  }
+
+  static std::string RAToString(long double ra, char delimiter) {
+    const long double partsPerHour = 60.0L * 60.0L * 1000.0L;
+    long double hrs = fmodl(ra * (12.0L / M_PIl), 24.0L);
+    hrs = roundl(hrs * partsPerHour) / partsPerHour;
+    std::stringstream s;
+    if (hrs < 0) {
+      hrs = -hrs;
+      s << '-';
+    }
+    hrs = (roundl(hrs * partsPerHour) + 0.5) / partsPerHour;
+    int hrsInt = int(floorl(hrs)),
+        minInt = int(floorl(fmodl(hrs, 1.0L) * 60.0L)),
+        secInt = int(floorl(fmodl(hrs * 60.0L, 1.0L) * (60.0L))),
+        subSecInt = int(floorl(fmodl(hrs * (60.0L * 60.0L), 1.0L) * (1000.0L)));
+    s << (char)((hrsInt / 10) + '0') << (char)((hrsInt % 10) + '0') << delimiter
+      << (char)((minInt / 10) + '0') << (char)((minInt % 10) + '0') << delimiter
+      << (char)((secInt / 10) + '0') << (char)((secInt % 10) + '0');
+    s << '.' << (char)(subSecInt / 100 + '0');
+    if (subSecInt % 100 != 0) {
+      s << (char)((subSecInt % 100) / 10 + '0');
+      if (subSecInt % 10 != 0) s << (char)((subSecInt % 10) + '0');
+    }
+    return s.str();
+  }
+
+  static std::string RaDecToString(long double ra, long double dec) {
+    return RAToString(ra) + ' ' + DecToString(dec);
+  }
+
+  static void RAToHMS(long double ra, int& hrs, int& min, double& sec) {
+    const long double partsPerHour = 60.0L * 60.0L * 100.0L;
+    long double hrsf = fmodl(ra * (12.0L / M_PIl), 24.0L);
+    hrsf = roundl(hrsf * partsPerHour) / partsPerHour;
+    bool negate = hrsf < 0;
+    if (negate) {
+      hrsf = -hrsf;
+    }
+    hrsf = (roundl(hrsf * partsPerHour) + 0.5) / partsPerHour;
+    if (negate)
+      hrs = -int(floorl(hrsf));
+    else
+      hrs = int(floorl(hrsf));
+    min = int(floorl(fmodl(hrsf, 1.0L) * 60.0L));
+    sec = floorl(100.0L * fmodl(hrsf * 60.0L, 1.0L) * 60.0L) / 100.0L;
+  }
+
+  static std::string DecToString(long double dec) {
+    const long double partsPerDeg = 60.0L * 60.0L * 1000.0L;
+    long double deg = dec * (180.0L / M_PIl);
+    deg = round(deg * partsPerDeg) / partsPerDeg;
+    std::stringstream s;
+    if (deg < 0) {
+      deg = -deg;
+      s << '-';
+    }
+    deg = (round(deg * partsPerDeg) + 0.5L) / partsPerDeg;
+    int degInt = int(floorl(deg)),
+        minInt = int(floorl(fmodl(deg, 1.0L) * 60.0L)),
+        secInt = int(floorl(fmodl(deg, 1.0L / 60.0L) * (60.0L * 60.0L))),
+        subSecInt = int(floorl(fmodl(deg, 1.0L / 60.0L / 60.0L) *
+                               (60.0L * 60.0L * 1000.0L)));
+    s << (char)((degInt / 10) + '0') << (char)((degInt % 10) + '0') << 'd'
+      << (char)((minInt / 10) + '0') << (char)((minInt % 10) + '0') << 'm'
+      << (char)((secInt / 10) + '0') << (char)((secInt % 10) + '0');
+    if (subSecInt != 0) {
+      s << '.' << (char)(subSecInt / 100 + '0');
+      if (subSecInt % 100 != 0) {
+        s << (char)((subSecInt / 10) % 10 + '0');
+        if (subSecInt % 10 != 0) s << (char)(subSecInt % 10 + '0');
+      }
+    }
+    s << 's';
+    return s.str();
+  }
+
+  static std::string DecToString(long double dec, char delimiter) {
+    const long double partsPerDeg = 60.0L * 60.0L * 1000.0L;
+    long double deg = dec * (180.0L / M_PIl);
+    deg = roundl(deg * partsPerDeg) / partsPerDeg;
+    std::stringstream s;
+    if (deg < 0) {
+      deg = -deg;
+      s << '-';
+    }
+    deg = (roundl(deg * partsPerDeg) + 0.5L) / partsPerDeg;
+    int degInt = int(floorl(deg)),
+        minInt = int(floorl(fmodl(deg, 1.0L) * 60.0L)),
+        secInt = int(floorl(fmodl(deg, 1.0L / 60.0L) * (60.0L * 60.0L))),
+        subSecInt = int(floorl(fmodl(deg, 1.0L / 60.0L / 60.0L) *
+                               (60.0L * 60.0L * 1000.0L)));
+    s << (char)((degInt / 10) + '0') << (char)((degInt % 10) + '0') << delimiter
+      << (char)((minInt / 10) + '0') << (char)((minInt % 10) + '0') << delimiter
+      << (char)((secInt / 10) + '0') << (char)((secInt % 10) + '0');
+    if (subSecInt != 0) {
+      s << '.' << (char)(subSecInt / 100 + '0');
+      if (subSecInt % 100 != 0) {
+        s << (char)((subSecInt / 10) % 10 + '0');
+        if (subSecInt % 10 != 0) s << (char)(subSecInt % 10 + '0');
+      }
+    }
+    return s.str();
+  }
+
+  static void DecToDMS(long double dec, int& deg, int& min, double& sec) {
+    const long double partsPerDeg = 60.0L * 60.0L * 100.0L;
+    long double degf = dec * (180.0 / M_PIl);
+    degf = round(degf * partsPerDeg) / partsPerDeg;
+    bool negate = degf < 0;
+    if (negate) {
+      degf = -degf;
+    }
+    degf = (round(degf * partsPerDeg) + 0.5) / partsPerDeg;
+
+    if (negate)
+      deg = -int(floor(degf));
+    else
+      deg = int(floor(degf));
+    min = int(floor(fmod(degf, 1.0) * 60.0)),
+    sec = floor(100. * fmod(degf, 1.0 / 60.0) * (60.0 * 60.0)) / 100.0;
+  }
+
+ private:
+  RaDecCoord() {}
+};
+}  // namespace aocommon
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/staticfor.h
@@ -0,0 +1,281 @@
+#ifndef STATIC_FOR_H
+#define STATIC_FOR_H
+
+#include "barrier.h"
+
+#include <atomic>
+#include <condition_variable>
+#include <cstring>
+#include <mutex>
+#include <thread>
+#include <vector>
+
+#include <sched.h>
+
+namespace aocommon {
+
+template <typename Iter>
+class StaticFor {
+ public:
+  StaticFor(size_t nThreads)
+      : _nThreads(nThreads),
+        _barrier(nThreads, [&]() { _hasTasks = false; }),
+        _stop(false),
+        _hasTasks(false) {}
+
+  ~StaticFor() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    if (!_threads.empty()) {
+      _stop = true;
+      _hasTasks = true;
+      _conditionChanged.notify_all();
+      lock.unlock();
+      for (std::thread &thr : _threads) thr.join();
+    }
+  }
+
+  /**
+   * Iteratively call a function in parallel.
+   *
+   * The function is expected to accept two size_t parameters, the loop
+   * index and the thread id, e.g.:
+   *   void loopFunction(size_t chunkStart, size_t chunkEnd);
+   */
+  void Run(Iter start, Iter end, std::function<void(Iter, Iter)> function) {
+    Run(start, end, _nThreads, std::move(function));
+  }
+
+  /**
+   * Iteratively call a function in parallel.
+   *
+   * The function is expected to accept two size_t parameters, the loop
+   * index and the thread id, e.g.:
+   *   void loopFunction(size_t chunkStart, size_t chunkEnd);
+   */
+  void Run(Iter start, Iter end, size_t nChunks,
+           std::function<void(Iter, Iter)> function) {
+    if (end == start + 1) {
+      function(start, end);
+    } else {
+      if (_threads.empty()) startThreads();
+      std::unique_lock<std::mutex> lock(_mutex);
+      _iterStart = start;
+      _iterEnd = end;
+      _currentChunk = 0;
+      _nChunks = std::min(nChunks, std::min(end - start, _nThreads));
+      _loopFunction = std::move(function);
+      _hasTasks = true;
+      _conditionChanged.notify_all();
+      lock.unlock();
+      loop();
+      _barrier.wait();
+    }
+  }
+
+  size_t NThreads() const { return _nThreads; }
+
+  /**
+   * This method is only allowed to be called before Run() is
+   * called.
+   */
+  void SetNThreads(size_t nThreads) {
+    if (_threads.empty()) {
+      _nThreads = nThreads;
+      _barrier = Barrier(nThreads, [&]() { _hasTasks = false; });
+    } else {
+      throw std::runtime_error("Can not set NThreads after calling Run()");
+    }
+  }
+
+ private:
+  StaticFor(const StaticFor &) = delete;
+
+  void loop() {
+    size_t chunk;
+    while (next(chunk)) {
+      Iter chunkStart = _iterStart + (_iterEnd - _iterStart) * chunk / _nChunks;
+      Iter chunkEnd =
+          _iterStart + (_iterEnd - _iterStart) * (chunk + 1) / _nChunks;
+      _loopFunction(chunkStart, chunkEnd);
+    }
+  }
+
+  void run() {
+    waitForTasks();
+    while (!_stop) {
+      loop();
+      _barrier.wait();
+      waitForTasks();
+    }
+  }
+
+  bool next(size_t &chunk) {
+    std::lock_guard<std::mutex> lock(_mutex);
+    if (_currentChunk == _nChunks)
+      return false;
+    else {
+      chunk = _currentChunk;
+      ++_currentChunk;
+      return true;
+    }
+  }
+
+  void waitForTasks() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    while (!_hasTasks) _conditionChanged.wait(lock);
+  }
+
+  void startThreads() {
+    if (_nThreads > 1) {
+      _threads.reserve(_nThreads - 1);
+      for (unsigned t = 1; t != _nThreads; ++t)
+        _threads.emplace_back(&StaticFor::run, this);
+    }
+  }
+
+  size_t _currentChunk, _nChunks;
+  Iter _iterStart, _iterEnd;
+  std::mutex _mutex;
+  size_t _nThreads;
+  Barrier _barrier;
+  std::atomic<bool> _stop;
+  bool _hasTasks;
+  std::condition_variable _conditionChanged;
+  std::vector<std::thread> _threads;
+  std::function<void(Iter, Iter)> _loopFunction;
+};
+
+template <typename Iter>
+class StaticTFor {
+ public:
+  StaticTFor(size_t nThreads)
+      : _nThreads(nThreads),
+        _barrier(nThreads, [&]() { _hasTasks = false; }),
+        _stop(false),
+        _hasTasks(false) {}
+
+  ~StaticTFor() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    if (!_threads.empty()) {
+      _stop = true;
+      _hasTasks = true;
+      _conditionChanged.notify_all();
+      lock.unlock();
+      for (std::thread &thr : _threads) thr.join();
+    }
+  }
+
+  /**
+   * Iteratively call a function in parallel.
+   *
+   * The function is expected to accept two size_t parameters, the loop
+   * index and the thread id, e.g.:
+   *   void loopFunction(size_t chunkStart, size_t chunkEnd);
+   */
+  void Run(Iter start, Iter end,
+           std::function<void(Iter, Iter, size_t)> function) {
+    Run(start, end, _nThreads, std::move(function));
+  }
+
+  /**
+   * Iteratively call a function in parallel.
+   *
+   * The function is expected to accept two size_t parameters, the loop
+   * index and the thread id, e.g.:
+   *   void loopFunction(size_t chunkStart, size_t chunkEnd);
+   */
+  void Run(Iter start, Iter end, size_t nChunks,
+           std::function<void(Iter, Iter, size_t)> function) {
+    if (end == start + 1) {
+      function(start, end, 0);
+    } else {
+      if (_threads.empty()) startThreads();
+      std::unique_lock<std::mutex> lock(_mutex);
+      _iterStart = start;
+      _iterEnd = end;
+      _currentChunk = 0;
+      _nChunks = std::min(nChunks, std::min(end - start, _nThreads));
+      _loopFunction = std::move(function);
+      _hasTasks = true;
+      _conditionChanged.notify_all();
+      lock.unlock();
+      loop(0);
+      _barrier.wait();
+    }
+  }
+
+  size_t NThreads() const { return _nThreads; }
+
+  /**
+   * This method is only allowed to be called before Run() is
+   * called.
+   */
+  void SetNThreads(size_t nThreads) {
+    if (_threads.empty()) {
+      _nThreads = nThreads;
+      _barrier = Barrier(nThreads, [&]() { _hasTasks = false; });
+    } else {
+      throw std::runtime_error("Can not set NThreads after calling Run()");
+    }
+  }
+
+ private:
+  StaticTFor(const StaticTFor &) = delete;
+
+  void loop(size_t threadId) {
+    size_t chunk;
+    while (next(chunk)) {
+      Iter chunkStart = _iterStart + (_iterEnd - _iterStart) * chunk / _nChunks;
+      Iter chunkEnd =
+          _iterStart + (_iterEnd - _iterStart) * (chunk + 1) / _nChunks;
+      _loopFunction(chunkStart, chunkEnd, threadId);
+    }
+  }
+
+  void run(size_t threadId) {
+    waitForTasks();
+    while (!_stop) {
+      loop(threadId);
+      _barrier.wait();
+      waitForTasks();
+    }
+  }
+
+  bool next(size_t &chunk) {
+    std::lock_guard<std::mutex> lock(_mutex);
+    if (_currentChunk == _nChunks)
+      return false;
+    else {
+      chunk = _currentChunk;
+      ++_currentChunk;
+      return true;
+    }
+  }
+
+  void waitForTasks() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    while (!_hasTasks) _conditionChanged.wait(lock);
+  }
+
+  void startThreads() {
+    if (_nThreads > 1) {
+      _threads.reserve(_nThreads - 1);
+      for (unsigned t = 1; t != _nThreads; ++t)
+        _threads.emplace_back(&StaticTFor::run, this, t);
+    }
+  }
+
+  size_t _currentChunk, _nChunks;
+  Iter _iterStart, _iterEnd;
+  std::mutex _mutex;
+  size_t _nThreads;
+  Barrier _barrier;
+  std::atomic<bool> _stop;
+  bool _hasTasks;
+  std::condition_variable _conditionChanged;
+  std::vector<std::thread> _threads;
+  std::function<void(Iter, Iter, size_t)> _loopFunction;
+};
+}  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/threadpool.h
@@ -0,0 +1,193 @@
+#ifndef THREAD_POOL_H
+#define THREAD_POOL_H
+
+#include <sched.h>
+
+#include <condition_variable>
+#include <functional>
+#include <map>
+#include <mutex>
+#include <thread>
+#include <vector>
+
+namespace aocommon {
+
+/// \brief Defines a class for managing threads.
+class ThreadPool {
+ public:
+  /**
+   * Create a thread pool with NThreads()==NCPUs().
+   */
+  ThreadPool() : ThreadPool(NCPUs()){};
+
+  /**
+   * Create a thread pool with the specified number of threads.
+   */
+  ThreadPool(size_t nthreads) : _isStopped(false), _priority(0) {
+    if (nthreads == 0)
+      throw std::runtime_error("A ThreadPool was created with nthreads=0");
+    // We reserve one thread less, because we always want a new For loop
+    // to be able to add a new thread (with index 0).
+    _threads.reserve(nthreads - 1);
+    for (size_t i = 1; i != nthreads; ++i)
+      _threads.emplace_back(&ThreadPool::threadFunc, this, i);
+  }
+
+  ThreadPool(const ThreadPool &) = delete;
+  ThreadPool &operator=(const ThreadPool &) = delete;
+
+  ~ThreadPool() {
+    std::unique_lock<std::mutex> lock(_mutex);
+    _isStopped = true;
+    _onProgress.notify_all();
+    lock.unlock();
+    for (std::thread &t : _threads) t.join();
+  }
+
+  size_t NThreads() const { return _threads.size() + 1; }
+
+  void SetNThreads(size_t nThreads) {
+    if (nThreads != NThreads()) {
+      std::unique_lock<std::mutex> lock(_mutex);
+      _isStopped = true;
+      _onProgress.notify_all();
+      lock.unlock();
+      for (std::thread &t : _threads) t.join();
+
+      _threads.clear();
+
+      _threads.reserve(nThreads - 1);
+      for (size_t i = 1; i != nThreads; ++i)
+        _threads.emplace_back(&ThreadPool::threadFunc, this, i);
+    }
+  }
+
+  /**
+   * Iteratively call a function in parallel.
+   *
+   * The function is expected to accept two size_t parameters, the loop
+   * index and the thread id, e.g.:
+   *   void loopFunction(size_t iteration, size_t threadID);
+   * It is called (end-start) times.
+   */
+  template <typename Func>
+  void For(size_t start, size_t end, Func func) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    size_t thisPriority = _priority;
+    ++_priority;
+    lock.unlock();
+
+    size_t progress = end - start;
+
+    std::thread localThread(&ThreadPool::threadSpecificPriorityFunc, this, 0,
+                            thisPriority, &progress);
+
+    // Queue tasks for all iterations
+    while (start != end) {
+      write(thisPriority, std::bind(func, start, std::placeholders::_1),
+            &progress);
+      ++start;
+    }
+
+    localThread.join();
+  }
+
+  static unsigned NCPUs() {
+#ifdef __APPLE__
+    return sysconf(_SC_NPROCESSORS_ONLN);
+#else
+    cpu_set_t cs;
+    CPU_ZERO(&cs);
+    sched_getaffinity(0, sizeof cs, &cs);
+
+    int count = 0;
+    for (int i = 0; i < CPU_SETSIZE; i++) {
+      if (CPU_ISSET(i, &cs)) ++count;
+    }
+    return count;
+#endif
+  }
+
+ private:
+  void threadFunc(size_t threadId) {
+    std::pair<std::function<void(size_t)>, size_t *> func;
+    while (read_highest_priority(func)) {
+      func.first(threadId);
+
+      std::unique_lock<std::mutex> lock(_mutex);
+      --(*func.second);  // decrease progress counter (requires lock)
+      _onProgress.notify_all();
+    }
+  }
+
+  void threadSpecificPriorityFunc(size_t threadId, size_t priority,
+                                  size_t *progressPtr) {
+    std::pair<std::function<void(size_t)>, size_t *> func;
+    while (read_specific_priority(priority, func, progressPtr)) {
+      func.first(threadId);
+
+      std::unique_lock<std::mutex> lock(_mutex);
+      --(*progressPtr);
+      _onProgress.notify_all();
+    }
+  }
+
+  bool read_highest_priority(
+      std::pair<std::function<void(size_t)>, size_t *> &func) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    while (!_isStopped && _tasks.empty()) _onProgress.wait(lock);
+    if (!_tasks.empty()) {
+      func = std::move(_tasks.begin()->second);
+      _tasks.erase(_tasks.begin());
+      _onProgress.notify_all();
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  bool read_specific_priority(
+      size_t priority, std::pair<std::function<void(size_t)>, size_t *> &func,
+      size_t *progress) {
+    std::unique_lock<std::mutex> lock(_mutex);
+    auto iter = _tasks.find(priority);
+    while (!_isStopped && (*progress) > 0 && iter == _tasks.end()) {
+      _onProgress.wait(lock);
+      iter = _tasks.find(priority);
+    }
+    if (iter != _tasks.end()) {
+      func = std::move(iter->second);
+      _tasks.erase(iter);
+      _onProgress.notify_all();
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  void write(size_t priority, std::function<void(size_t)> &&func,
+             size_t *progressPtr) {
+    // Wait until there is space in the map (so that the map
+    // doesn't get too large)
+    std::unique_lock<std::mutex> lock(_mutex);
+    while (_tasks.count(priority) >= NThreads()) {
+      _onProgress.wait(lock);
+    }
+    _tasks.emplace(priority, std::make_pair(std::move(func), progressPtr));
+    _onProgress.notify_all();
+  }
+
+  // Priority, (function, progress*)
+  bool _isStopped;
+  size_t _priority;
+  std::multimap<size_t, std::pair<std::function<void(size_t)>, size_t *>,
+                std::greater<size_t>>
+      _tasks;
+  std::vector<std::thread> _threads;
+  std::mutex _mutex;
+  std::condition_variable _onProgress;
+};
+
+};  // namespace aocommon
+
+#endif
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/uvector.h
@@ -0,0 +1,1206 @@
+#ifndef AO_UVECTOR_11_H
+#define AO_UVECTOR_11_H
+
+#include <algorithm>
+#include <cstring>
+#include <iterator>
+#include <memory>
+#include <stdexcept>
+#include <utility>
+
+/**
+ * @file uvector.h
+ * Header file for UVector and its relational and swap functions.
+ * @author André Offringa
+ * @copyright André Offringa, 2013, distributed under the GPL license version 3.
+ */
+
+namespace aocommon {
+
+/**
+ * @defgroup UVector Class UVector and related functions.
+ * @{
+ */
+
+/**
+ * @brief A container similar to std::vector, but one that allows construction
+ * without initializing its elements.
+ * @details This container is similar to a std::vector, except that it can be
+ * constructed without initializing its elements. This saves the overhead of
+ * initialization, hence the constructor @ref UVector(size_t) is significantly
+ * faster than the corresponding std::vector constructor, and has no overhead
+ * compared to a manually allocated array.
+ *
+ * Probably its greatest strength lies in the construction of containers with a
+ * number of elements that is runtime defined, but that will be initialized
+ * later. For example:
+ *
+ * @code
+ * // Open a file
+ * ifstream file("myfile.bin");
+ *
+ * // Construct a buffer for this file
+ * UVector<char> buffer(buffer_size);
+ *
+ * // Read some data into the buffer
+ * file.read(&buffer[0], buffer_size);
+ * @endcode
+ *
+ * However, it has a few more use-cases with improved performance over
+ * std::vector. This is possible because of more strengent requirements on the
+ * element's type.
+ *
+ * The container will behave correctly with any trivial type, but will not work
+ * for almost all non-trivial types.
+ *
+ * The methods with different semantics compared to std::vector are:
+ * * @ref UVector(size_t n)
+ * * @ref resize(size_t n)
+ *
+ * Also the following new members are introduced:
+ * * @ref insert_uninitialized(const_iterator position, size_t n)
+ * * @ref push_back(InputIterator first, InputIterator last)
+ * * @ref push_back(size_t n, const Tp& val)
+ * * @ref push_back(std::initializer_list<Tp> initlist)
+ * * @ref push_back_uninitialized(size_t n)
+ *
+ * All other members work exactly like std::vector's members, although some are
+ * slightly faster because of the stricter requirements on the element type.
+ *
+ * @tparam Tp Container's element type
+ * @tparam Alloc Allocator type. Default is to use the std::allocator.
+ *
+ * @author André Offringa
+ * @copyright André Offringa, 2013, distributed under the GPL license version 3.
+ */
+template <typename Tp, typename Alloc = std::allocator<Tp>>
+class UVector : private Alloc {
+  static_assert(std::is_standard_layout<Tp>(),
+                "A UVector can only hold classes with standard layout");
+
+ public:
+  /// Element type
+  typedef Tp value_type;
+  /// Type of allocator used to allocate and deallocate space
+  typedef Alloc allocator_type;
+  /// Reference to element type
+  typedef Tp &reference;
+  /// Constant reference to element type
+  typedef const Tp &const_reference;
+  /// Pointer to element type
+  typedef Tp *pointer;
+  /// Pointer to constant element type
+  typedef const Tp *const_pointer;
+  /// Iterator type
+  typedef Tp *iterator;
+  /// Iterator type of constant elements
+  typedef const Tp *const_iterator;
+  /// Reverse iterator type
+  typedef std::reverse_iterator<iterator> reverse_iterator;
+  /// Reverse iterator of constant elements
+  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
+  /// Difference between to iterators
+  typedef std::ptrdiff_t difference_type;
+  /// Type used for indexing elements
+  typedef std::size_t size_t;
+  /// Type used for indexing elements
+  typedef std::size_t size_type;
+
+ private:
+#if __cplusplus > 201402L
+  typedef typename std::allocator_traits<allocator_type>::is_always_equal
+      allocator_is_always_equal;
+#else
+  typedef std::false_type allocator_is_always_equal;
+#endif
+  pointer _begin, _end, _endOfStorage;
+
+ public:
+  /** @brief Construct an empty UVector.
+   * @param allocator Allocator used for allocating and deallocating memory.
+   */
+  explicit UVector(const allocator_type &allocator = Alloc()) noexcept
+      : Alloc(allocator),
+        _begin(nullptr),
+        _end(nullptr),
+        _endOfStorage(nullptr) {}
+
+  /** @brief Construct a vector with given amount of elements, without
+   * initializing these.
+   * @details This constructor deviates from std::vector's behaviour, because it
+   * will not value construct its elements. It is therefore faster than the
+   * corresponding constructor of std::vector.
+   * @param n Number of elements that the UVector will be initialized with.
+   */
+  explicit UVector(size_t n)
+      : _begin(allocate(n)), _end(_begin + n), _endOfStorage(_end) {}
+
+  /** @brief Construct a vector with given amount of elements and set these to a
+   * specific value.
+   * @details This constructor will initialize its members with the given value.
+   * @param n Number of elements that the UVector will be initialized with.
+   * @param val Value to initialize all elements with
+   * @param allocator Allocator used for allocating and deallocating memory.
+   */
+  UVector(size_t n, const value_type &val,
+          const allocator_type &allocator = Alloc())
+      : Alloc(allocator),
+        _begin(allocate(n)),
+        _end(_begin + n),
+        _endOfStorage(_end) {
+    std::uninitialized_fill_n<Tp *, size_t>(_begin, n, val);
+  }
+
+  /** @brief Construct a vector by copying elements from a range.
+   * @param first Iterator to range start
+   * @param last Iterator to range end
+   * @param allocator Allocator used for allocating and deallocating memory.
+   */
+  template <class InputIterator>
+  UVector(InputIterator first, InputIterator last,
+          const allocator_type &allocator = Alloc())
+      : Alloc(allocator) {
+    construct_from_range<InputIterator>(first, last,
+                                        std::is_integral<InputIterator>());
+  }
+
+  /** @brief Copy construct a UVector.
+   * @details The allocator of the new UVector will be initialized from
+   * @c
+   * std::allocator_traits<Alloc>::select_on_container_copy_construction(other).
+   * @param other Source UVector to be copied from.
+   */
+  UVector(const UVector<Tp, Alloc> &other)
+      : Alloc(
+            std::allocator_traits<Alloc>::select_on_container_copy_construction(
+                static_cast<allocator_type>(other))),
+        _begin(allocate(other.size())),
+        _end(_begin + other.size()),
+        _endOfStorage(_end) {
+    std::copy(other._begin, other._end, _begin);
+  }
+
+  /** @brief Copy construct a UVector with custom allocator.
+   * @param other Source UVector to be copied from.
+   * @param allocator Allocator used for allocating and deallocating memory.
+   */
+  UVector(const UVector<Tp, Alloc> &other, const allocator_type &allocator)
+      : Alloc(allocator),
+        _begin(allocate(other.size())),
+        _end(_begin + other.size()),
+        _endOfStorage(_end) {
+    std::copy(other._begin, other._end, _begin);
+  }
+
+  /** @brief Move construct a UVector.
+   * @param other Source UVector to be moved from.
+   */
+  UVector(UVector<Tp, Alloc> &&other) noexcept
+      : Alloc(std::move(other)),
+        _begin(other._begin),
+        _end(other._end),
+        _endOfStorage(other._endOfStorage) {
+    other._begin = nullptr;
+    other._end = nullptr;
+    other._endOfStorage = nullptr;
+  }
+
+  /** @brief Move construct a UVector with custom allocator.
+   * @param other Source UVector to be moved from.
+   * @param allocator Allocator used for allocating and deallocating memory.
+   */
+  UVector(UVector<Tp, Alloc> &&other, const allocator_type &allocator) noexcept
+      : Alloc(allocator),
+        _begin(other._begin),
+        _end(other._end),
+        _endOfStorage(other._endOfStorage) {
+    other._begin = nullptr;
+    other._end = nullptr;
+    other._endOfStorage = nullptr;
+  }
+
+  /** @brief Construct a UVector from a initializer list.
+   * @param initlist Initializer list used for initializing the new UVector.
+   * @param allocator Allocator used for allocating and deallocating memory.
+   */
+  UVector(std::initializer_list<Tp> initlist,
+          const allocator_type &allocator = Alloc())
+      : Alloc(allocator),
+        _begin(allocate(initlist.size())),
+        _end(_begin + initlist.size()),
+        _endOfStorage(_end) {
+    iterator destIter = _begin;
+    for (typename std::initializer_list<Tp>::const_iterator i =
+             initlist.begin();
+         i != initlist.end(); ++i) {
+      *destIter = *i;
+      ++destIter;
+    }
+  }
+
+  /** @brief Destructor. */
+  ~UVector() noexcept { deallocate(); }
+
+  /** @brief Assign another UVector to this UVector.
+   * @details The allocator of the UVector will be assigned to @p other when
+   * std::allocator_traits<Alloc>::propagate_on_container_copy_assignment() is
+   * of true_type.
+   */
+  UVector &operator=(const UVector<Tp, Alloc> &other) {
+    return assign_copy_from(
+        other, typename std::allocator_traits<
+                   Alloc>::propagate_on_container_copy_assignment());
+  }
+
+  /** @brief Assign another UVector to this UVector.
+   * @details The allocator of the UVector will be assigned to @p other when
+   * std::allocator_traits<Alloc>::propagate_on_container_move_assignment() is
+   * of true_type.
+   */
+  UVector &operator=(UVector<Tp, Alloc> &&other) noexcept(
+      std::allocator_traits<
+          Alloc>::propagate_on_container_move_assignment::value ||
+      allocator_is_always_equal::value) {
+    return assign_move_from(
+        std::move(other), typename std::allocator_traits<
+                              Alloc>::propagate_on_container_move_assignment());
+  }
+
+  /** @brief Get iterator to first element. */
+  iterator begin() noexcept { return _begin; }
+
+  /** @brief Get constant iterator to first element. */
+  const_iterator begin() const noexcept { return _begin; }
+
+  /** @brief Get iterator to element past last element. */
+  iterator end() noexcept { return _end; }
+
+  /** @brief Get constant iterator to element past last element. */
+  const_iterator end() const noexcept { return _end; }
+
+  /** @brief Get reverse iterator to last element. */
+  reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
+
+  /** @brief Get constant reverse iterator to last element. */
+  const_reverse_iterator rbegin() const noexcept {
+    return const_reverse_iterator(end());
+  }
+
+  /** @brief Get reverse iterator to element before first element. */
+  reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
+
+  /** @brief Get constant reverse iterator to element before first element. */
+  const_reverse_iterator rend() const noexcept {
+    return const_reverse_iterator(begin());
+  }
+
+  /** @brief Get constant iterator to first element. */
+  const_iterator cbegin() const noexcept { return _begin; }
+
+  /** @brief Get constant iterator to element past last element. */
+  const_iterator cend() const noexcept { return _end; }
+
+  /** @brief Get constant reverse iterator to last element. */
+  const_reverse_iterator crbegin() const noexcept {
+    return const_reverse_iterator(end());
+  }
+
+  /** @brief Get constant reverse iterator to element before first element. */
+  const_reverse_iterator crend() const noexcept {
+    return const_reverse_iterator(begin());
+  }
+
+  /** @brief Get number of elements in container. */
+  size_t size() const noexcept { return _end - _begin; }
+
+  /** @brief Get maximum number of elements that this container can hold. */
+  size_t max_size() const noexcept { return Alloc::max_size(); }
+
+  /** @brief Change the number of elements in the container.
+   * @details If the new size is larger than the current size, new values will
+   * be left uninitialized. Therefore, it is more efficient than @c
+   * resize(size_t) in
+   * @c std::vector, as well as @ref resize(size_t, const Tp&).
+   * If the new size is smaller than the current size, the container will be
+   * truncated and elements past the new size will be removed. No destructor of
+   * the removed elements will be called.
+   * @param n The new size of the container.
+   */
+  void resize(size_t n) {
+    if (capacity() < n) {
+      size_t newSize = enlarge_size(n);
+      pointer newStorage = allocate(newSize);
+      std::move(_begin, _end, newStorage);
+      deallocate();
+      _begin = newStorage;
+      _endOfStorage = _begin + newSize;
+    }
+    _end = _begin + n;
+  }
+
+  /** @brief Change the number of elements in the container.
+   * @details If the new size is larger than the current size, new values will
+   * be initialized by the given value. If the new size is smaller than the
+   * current size, the container will be truncated and elements past the new
+   * size will be removed. No destructor of the removed elements will be called.
+   * @param n The new size of the container.
+   * @param val New value of elements that get added to the container.
+   */
+  void resize(size_t n, const Tp &val) {
+    size_t oldSize = size();
+    if (capacity() < n) {
+      pointer newStorage = allocate(n);
+      std::move(_begin, _end, newStorage);
+      deallocate();
+      _begin = newStorage;
+      _endOfStorage = _begin + n;
+    }
+    _end = _begin + n;
+    if (oldSize < n)
+      std::uninitialized_fill<Tp *, size_t>(_begin + oldSize, _end, val);
+  }
+
+  /** @brief Get the number of elements the container can currently hold without
+   * reallocating storage. */
+  size_t capacity() const noexcept { return _endOfStorage - _begin; }
+
+  /** @brief Determine if the container is currently empty.
+   * @returns @c true if @ref size() == 0. */
+  bool empty() const noexcept { return _begin == _end; }
+
+  /** @brief Reserve space for a number of elements, to prevent the overhead of
+   * extra reallocations.
+   * @details This has no effect on the working of the UVector, except that it
+   * might change the current capacity. This can enhance performance when a
+   * large number of elements are added, and an approximate size is known a
+   * priori.
+   *
+   * This method might cause a reallocation, causing iterators to be
+   * invalidated.
+   * @param n Number of elements to reserve space for.
+   */
+  void reserve(size_t n) {
+    if (capacity() < n) {
+      const size_t curSize = size();
+      pointer newStorage = allocate(n);
+      std::move(_begin, _begin + curSize, newStorage);
+      deallocate();
+      _begin = newStorage;
+      _end = newStorage + curSize;
+      _endOfStorage = _begin + n;
+    }
+  }
+
+  /** @brief Change the capacity of the container such that no extra space is
+   * hold.
+   * @details This has no effect on the working of the UVector, except that it
+   * might change the current capacity. This can reduce the current memory usage
+   * of the container.
+   *
+   * This method might cause a reallocation, causing iterators to be
+   * invalidated.
+   */
+  void shrink_to_fit() {
+    const size_t curSize = size();
+    if (curSize == 0) {
+      deallocate();
+      _begin = nullptr;
+      _end = nullptr;
+      _endOfStorage = nullptr;
+    } else if (curSize < capacity()) {
+      pointer newStorage = allocate(curSize);
+      std::move(_begin, _begin + curSize, newStorage);
+      deallocate();
+      _begin = newStorage;
+      _end = newStorage + curSize;
+      _endOfStorage = _begin + curSize;
+    }
+  }
+
+  /** @brief Get a reference to the element at the given index. */
+  Tp &operator[](size_t index) noexcept { return _begin[index]; }
+
+  /** @brief Get a constant reference to the element at the given index. */
+  const Tp &operator[](size_t index) const noexcept { return _begin[index]; }
+
+  /** @brief Get a reference to the element at the given index with bounds
+   * checking.
+   * @throws std::out_of_range when given index is past the last element.
+   */
+  Tp &at(size_t index) {
+    check_bounds(index);
+    return _begin[index];
+  }
+
+  /** @brief Get a constant reference to the element at the given index with
+   * bounds checking.
+   * @throws std::out_of_range when given index is past the last element.
+   */
+  const Tp &at(size_t index) const {
+    check_bounds(index);
+    return _begin[index];
+  }
+
+  /** @brief Get reference to first element in container. */
+  Tp &front() noexcept { return *_begin; }
+
+  /** @brief Get constant reference to first element in container. */
+  const Tp &front() const noexcept { return *_begin; }
+
+  /** @brief Get reference to last element in container. */
+  Tp &back() noexcept { return *(_end - 1); }
+
+  /** @brief Get constant reference to last element in container. */
+  const Tp &back() const noexcept { return *(_end - 1); }
+
+  /** @brief Get pointer to internal storage. */
+  Tp *data() noexcept { return _begin; }
+
+  /** @brief Get constant pointer to internal storage. */
+  const Tp *data() const noexcept { return _begin; }
+
+  /** @brief Assign this container to be equal to the given range.
+   * @details The container will be resized to fit the length of the given
+   * range. Iterators are invalidated.
+   * @param first Iterator to the beginning of the range.
+   * @param last Iterator past the end of the range.
+   */
+  template <class InputIterator>
+  void assign(InputIterator first, InputIterator last) {
+    assign_from_range<InputIterator>(first, last,
+                                     std::is_integral<InputIterator>());
+  }
+
+  /** @brief Resize the container and assign the given value to all elements.
+   * @details Iterators are invalidated.
+   * @param n New size of container
+   * @param val Value to be assigned to all elements.
+   */
+  void assign(size_t n, const Tp &val) {
+    if (n > capacity()) {
+      iterator newStorage = allocate(n);
+      deallocate();
+      _begin = newStorage;
+      _endOfStorage = _begin + n;
+    }
+    _end = _begin + n;
+    std::uninitialized_fill_n<Tp *, size_t>(_begin, n, val);
+  }
+
+  /** @brief Assign this container to an initializer list.
+   * @details The container will be resized to fit the length of the given
+   * initializer list. Iterators are invalidated.
+   * @param initlist List of values to assign to the container.
+   */
+  void assign(std::initializer_list<Tp> initlist) {
+    if (initlist.size() > capacity()) {
+      iterator newStorage = allocate(initlist.size());
+      deallocate();
+      _begin = newStorage;
+      _endOfStorage = _begin + initlist.size();
+    }
+    _end = _begin + initlist.size();
+    iterator destIter = _begin;
+    for (typename std::initializer_list<Tp>::const_iterator i =
+             initlist.begin();
+         i != initlist.end(); ++i) {
+      *destIter = *i;
+      ++destIter;
+    }
+  }
+
+  /** @brief Add the given value to the end of the container.
+   * @details Iterators are invalidated.
+   * @param item Value of new element.
+   */
+  void push_back(const Tp &item) {
+    if (_end == _endOfStorage) enlarge(enlarge_size(1));
+    *_end = item;
+    ++_end;
+  }
+
+  /** @brief Add the given value to the end of the container by moving it in.
+   * @details Iterators are invalidated.
+   *
+   * Note that this container can only hold simple types that do not perform
+   * allocations. Therefore, there is probably no benefit in moving the new item
+   * in over copying it in with @ref push_back(const Tp&).
+   * @param item Value of new element.
+   */
+  void push_back(Tp &&item) {
+    if (_end == _endOfStorage) enlarge(enlarge_size(1));
+    *_end = std::move(item);
+    ++_end;
+  }
+
+  /** @brief Remove the last element from the container. */
+  void pop_back() { --_end; }
+
+  /** @brief Insert an element at a given position.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive.
+   * @param position Position of the new element. The new element will be added
+   * before the old element at that position.
+   * @param item Value of the new item.
+   * @return Position of the new element.
+   */
+  iterator insert(const_iterator position, const Tp &item) {
+    if (_end == _endOfStorage) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(1), index, 1);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + 1);
+      ++_end;
+    }
+    *const_cast<iterator>(position) = item;
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Insert elements at a given position and initialize them with a
+   * value.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive.
+   * @param position Position of the new elements. The new elements will be
+   * added before the old element at that position.
+   * @param n Number of elements to add.
+   * @param val Value of the new item.
+   * @return Position of the first new element.
+   */
+  iterator insert(const_iterator position, size_t n, const Tp &val) {
+    if (capacity() < size() + n) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(n), index, n);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + n);
+      _end += n;
+    }
+    std::uninitialized_fill_n<Tp *, size_t>(const_cast<iterator>(position), n,
+                                            val);
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Insert elements at a given position and initialize them from a
+   * range.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive.
+   * @param position Position of the new elements. The new elements will be
+   * added before the old element at that position.
+   * @param first Iterator to the beginning of the range.
+   * @param last Iterator past the end of the range.
+   * @return Position of the first new element.
+   */
+  template <class InputIterator>
+  iterator insert(const_iterator position, InputIterator first,
+                  InputIterator last) {
+    return insert_from_range<InputIterator>(position, first, last,
+                                            std::is_integral<InputIterator>());
+  }
+
+  /** @brief Insert an element at a given position by moving it in.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive.
+   *
+   * Note that this container can only hold simple types that do not perform
+   * allocations. Therefore, there is probably no benefit in moving the new item
+   * in over copying it in with
+   * @ref insert(const_iterator, const Tp&).
+   * @param position Position of the new element. The new element will be added
+   * before the old element at that position.
+   * @param item Value of the new item.
+   * @return Position of the new element.
+   */
+  iterator insert(const_iterator position, Tp &&item) {
+    if (_end == _endOfStorage) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(1), index, 1);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + 1);
+      ++_end;
+    }
+    *const_cast<iterator>(position) = std::move(item);
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Insert elements at a given position and initialize them from a
+   * initializer list.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive.
+   * @param position Position of the new elements. The new elements will be
+   * added before the old element at that position.
+   * @param initlist List of items to insert.
+   * @return Position of the first new element.
+   */
+  iterator insert(const_iterator position, std::initializer_list<Tp> initlist) {
+    if (capacity() < size() + initlist.size()) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(initlist.size()), index, initlist.size());
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end,
+                         _end + initlist.size());
+      _end += initlist.size();
+    }
+    iterator destIter = const_cast<iterator>(position);
+    for (typename std::initializer_list<Tp>::const_iterator i =
+             initlist.begin();
+         i != initlist.end(); ++i) {
+      *destIter = *i;
+      ++destIter;
+    }
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Delete an element from the container.
+   * @details This operation moves all elements past the removed element, and
+   * can therefore be expensive.
+   * @param position Position of element to be removed.
+   * @return Iterator pointing to the first element past the delete element.
+   */
+  iterator erase(const_iterator position) {
+    std::move(const_cast<iterator>(position) + 1, _end,
+              const_cast<iterator>(position));
+    --_end;
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Delete a range of elements from the container.
+   * @details This operation moves all elements past the removed elements, and
+   * can therefore be expensive.
+   * @param first Position of first element to be removed.
+   * @param last Position past last element to be removed.
+   * @return Iterator pointing to the first element past the delete element.
+   */
+  iterator erase(const_iterator first, const_iterator last) {
+    std::move(const_cast<iterator>(last), _end, const_cast<iterator>(first));
+    _end -= last - first;
+    return const_cast<iterator>(first);
+  }
+
+  /** @brief Swap the contents of this UVector with the given UVector.
+   * @details Iterators to both vectors will remain valid and will point into
+   * to the swapped container afterwards. This function will never reallocate
+   * space.
+   *
+   * The allocator will be swapped when the @c propagate_on_container_swap
+   * of the respective @c allocator_trait is @c true_type.
+   * Its behaviour is undefined when the allocators do not compare equal and
+   * @c propagate_on_container_swap is false.
+   * @param other Other UVector whose contents it to be swapped with this.
+   */
+  void swap(UVector<Tp, Alloc> &other) noexcept {
+    swap(other,
+         typename std::allocator_traits<Alloc>::propagate_on_container_swap());
+  }
+
+  /** @brief Remove all elements from the container. */
+  void clear() { _end = _begin; }
+
+  /** @brief Insert an element at a given position by constructing it in place.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive.
+   * @param position Position of the new element. The new element will be added
+   * before the old element at that position.
+   * @param args List of arguments to be forwarded to construct the new element.
+   * @return Position of the new element.
+   */
+  template <typename... Args>
+  iterator emplace(const_iterator position, Args &&... args) {
+    if (_end == _endOfStorage) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(1), index, 1);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + 1);
+      ++_end;
+    }
+    *const_cast<iterator>(position) = Tp(std::forward<Args>(args)...);
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Add the given value to the end of the container by constructing it
+   * in place.
+   * @details Iterators are invalidated.
+   * @param args List of arguments to be forwarded to construct the new element.
+   */
+  template <typename... Args>
+  void emplace_back(Args &&... args) {
+    if (_end == _endOfStorage) enlarge(enlarge_size(1));
+    *_end = Tp(std::forward<Args>(args)...);
+    ++_end;
+  }
+
+  /** @brief Get a copy of the allocator. */
+  allocator_type get_allocator() const noexcept { return *this; }
+
+  // --- NON STANDARD METHODS ---
+
+  /** @brief Insert elements at a given position without initializing them.
+   * @details All iterators will be invalidated. This operation needs to move
+   * all elements after the new element, and can therefore be expensive. It will
+   * not initialize the new elements, and is therefore faster than @ref
+   * insert(const_iterator, size_t, const Tp&).
+   *
+   * This method is non-standard: it is not present in std::vector.
+   * @param position Position of the new elements. The new elements will be
+   * added before the old element at that position.
+   * @param n Number of elements to add.
+   */
+  iterator insert_uninitialized(const_iterator position, size_t n) {
+    if (capacity() < size() + n) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(n), index, n);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + n);
+      _end += n;
+    }
+    return const_cast<iterator>(position);
+  }
+
+  /** @brief Add a range of items to the end of the container.
+   * @details All iterators will be invalidated.
+   *
+   * This method is non-standard: it is not present in std::vector.
+   * @param first Iterator to the beginning of the range.
+   * @param last Iterator past the end of the range.
+   */
+  template <class InputIterator>
+  void push_back(InputIterator first, InputIterator last) {
+    push_back_range<InputIterator>(first, last,
+                                   std::is_integral<InputIterator>());
+  }
+
+  /** @brief Add elements at the end and initialize them with a value.
+   * @details All iterators will be invalidated.
+   *
+   * This method is non-standard: it is not present in std::vector.
+   * @param n Number of elements to add.
+   * @param val Value of the new items.
+   */
+  void push_back(size_t n, const Tp &val) {
+    if (capacity() - size() < n) {
+      enlarge(enlarge_size(n));
+    }
+    std::uninitialized_fill_n<Tp *, size_t>(_end, n, val);
+    _end += n;
+  }
+
+  /** @brief Add elements from an initializer list to the end of the container.
+   * @details All iterators will be invalidated.
+   *
+   * This method is non-standard: it is not present in std::vector.
+   * @param initlist The list with values to add.
+   */
+  void push_back(std::initializer_list<Tp> initlist) {
+    if (capacity() - size() < initlist.size()) {
+      enlarge(enlarge_size(initlist.size()));
+    }
+    for (typename std::initializer_list<Tp>::iterator i = initlist.begin();
+         i != initlist.end(); ++i) {
+      *_end = *i;
+      ++_end;
+    }
+  }
+
+  /** @brief Add elements at the end without initializing them.
+   * @details All iterators will be invalidated.
+   *
+   * This method is non-standard: it is not present in std::vector.
+   * @param n Number of elements to add.
+   */
+  void push_back_uninitialized(size_t n) { resize(size() + n); }
+
+ private:
+  pointer allocate(size_t n) { return Alloc::allocate(n); }
+
+  void deallocate() noexcept { deallocate(_begin, capacity()); }
+
+  void deallocate(pointer begin, size_t n) noexcept {
+    if (begin != nullptr) Alloc::deallocate(begin, n);
+  }
+
+  template <typename InputIterator>
+  void construct_from_range(InputIterator first, InputIterator last,
+                            std::false_type) {
+    construct_from_range<InputIterator>(
+        first, last,
+        typename std::iterator_traits<InputIterator>::iterator_category());
+  }
+
+  template <typename Integral>
+  void construct_from_range(Integral n, Integral val, std::true_type) {
+    _begin = allocate(n);
+    _end = _begin + n;
+    _endOfStorage = _end;
+    std::uninitialized_fill_n<Tp *, size_t>(_begin, n, val);
+  }
+
+  template <typename InputIterator>
+  void construct_from_range(InputIterator first, InputIterator last,
+                            std::forward_iterator_tag) {
+    size_t n = std::distance(first, last);
+    _begin = allocate(n);
+    _end = _begin + n;
+    _endOfStorage = _begin + n;
+    Tp *destIter = _begin;
+    while (first != last) {
+      *destIter = *first;
+      ++destIter;
+      ++first;
+    }
+  }
+
+  template <typename InputIterator>
+  void assign_from_range(InputIterator first, InputIterator last,
+                         std::false_type) {
+    assign_from_range<InputIterator>(
+        first, last,
+        typename std::iterator_traits<InputIterator>::iterator_category());
+  }
+
+  // This function is called from assign(iter,iter) when Tp is an integral. In
+  // that case, the user tried to call assign(n, &val), but it got caught by the
+  // wrong overload.
+  template <typename Integral>
+  void assign_from_range(Integral n, Integral val, std::true_type) {
+    if (size_t(n) > capacity()) {
+      iterator newStorage = allocate(n);
+      deallocate();
+      _begin = newStorage;
+      _endOfStorage = _begin + n;
+    }
+    _end = _begin + n;
+    std::uninitialized_fill_n<Tp *, size_t>(_begin, n, val);
+  }
+
+  template <typename InputIterator>
+  void assign_from_range(InputIterator first, InputIterator last,
+                         std::forward_iterator_tag) {
+    size_t n = std::distance(first, last);
+    if (n > capacity()) {
+      iterator newStorage = allocate(n);
+      deallocate();
+      _begin = newStorage;
+      _endOfStorage = _begin + n;
+    }
+    _end = _begin + n;
+    Tp *destIter = _begin;
+    while (first != last) {
+      *destIter = *first;
+      ++destIter;
+      ++first;
+    }
+  }
+
+  template <typename InputIterator>
+  iterator insert_from_range(const_iterator position, InputIterator first,
+                             InputIterator last, std::false_type) {
+    return insert_from_range<InputIterator>(
+        position, first, last,
+        typename std::iterator_traits<InputIterator>::iterator_category());
+  }
+
+  template <typename Integral>
+  iterator insert_from_range(const_iterator position, Integral n, Integral val,
+                             std::true_type) {
+    if (capacity() < size() + n) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(n), index, n);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + n);
+      _end += n;
+    }
+    std::uninitialized_fill_n<Tp *, size_t>(const_cast<iterator>(position), n,
+                                            val);
+    return const_cast<iterator>(position);
+  }
+
+  template <typename InputIterator>
+  iterator insert_from_range(const_iterator position, InputIterator first,
+                             InputIterator last, std::forward_iterator_tag) {
+    size_t n = std::distance(first, last);
+    if (capacity() < size() + n) {
+      size_t index = position - _begin;
+      enlarge_for_insert(enlarge_size(n), index, n);
+      position = _begin + index;
+    } else {
+      std::move_backward(const_cast<iterator>(position), _end, _end + n);
+      _end += n;
+    }
+    Tp *destIter = const_cast<iterator>(position);
+    while (first != last) {
+      *destIter = *first;
+      ++destIter;
+      ++first;
+    }
+    return const_cast<iterator>(position);
+  }
+
+  void check_bounds(size_t index) const {
+    if (index >= size())
+      throw std::out_of_range("Access to element in UVector past end");
+  }
+
+  size_t enlarge_size(size_t extra_space_needed) const noexcept {
+    return size() + std::max(size(), extra_space_needed);
+  }
+
+  void enlarge(size_t newSize) {
+    pointer newStorage = allocate(newSize);
+    std::copy(_begin, _end, newStorage);
+    deallocate();
+    _end = newStorage + size();
+    _begin = newStorage;
+    _endOfStorage = _begin + newSize;
+  }
+
+  void enlarge_for_insert(size_t newSize, size_t insert_position,
+                          size_t insert_count) {
+    pointer newStorage = allocate(newSize);
+    std::copy(_begin, _begin + insert_position, newStorage);
+    std::copy(_begin + insert_position, _end,
+              newStorage + insert_position + insert_count);
+    deallocate();
+    _end = newStorage + size() + insert_count;
+    _begin = newStorage;
+    _endOfStorage = _begin + newSize;
+  }
+
+  // implementation of operator=(const&) without
+  // propagate_on_container_copy_assignment
+  UVector &assign_copy_from(const UVector<Tp, Alloc> &other, std::false_type) {
+    const size_t n = other.size();
+    if (n > capacity()) {
+      iterator newStorage = allocate(n);
+      deallocate();
+      _begin = newStorage;
+      _end = _begin + n;
+      _endOfStorage = _end;
+    }
+    std::copy(other._begin, other._begin + n, _begin);
+    return *this;
+  }
+
+  // implementation of operator=(const&) with
+  // propagate_on_container_copy_assignment
+  UVector &assign_copy_from(const UVector<Tp, Alloc> &other, std::true_type) {
+    if (allocator_is_always_equal() ||
+        static_cast<Alloc &>(other) == static_cast<Alloc &>(*this)) {
+      assign_copy_from(other, std::false_type());
+    } else {
+      const size_t n = other.size();
+      iterator newStorage = static_cast<Alloc &>(other).allocate(n);
+      deallocate();
+      _begin = newStorage;
+      _end = _begin + n;
+      _endOfStorage = _end;
+      std::copy(other._begin, other._begin + n, _begin);
+      Alloc::operator=(static_cast<Alloc &>(other));
+    }
+    return *this;
+  }
+
+  // implementation of operator=() without
+  // propagate_on_container_move_assignment
+  UVector &assign_move_from(
+      UVector<Tp, Alloc> &&other,
+      std::false_type) noexcept(allocator_is_always_equal::value) {
+    if (allocator_is_always_equal::value ||
+        static_cast<Alloc &>(other) == static_cast<Alloc &>(*this)) {
+      deallocate();
+      _begin = other._begin;
+      _end = other._end;
+      _endOfStorage = other._endOfStorage;
+      other._begin = nullptr;
+      other._end = nullptr;
+      other._endOfStorage = nullptr;
+    } else {
+      // We should not propagate the allocator and the allocators are different.
+      // This means we can not swap the allocated space, since then we would
+      // deallocate the space with a different allocator type. Therefore, we
+      // need to copy:
+      assign_copy_from(other, std::false_type());
+    }
+    return *this;
+  }
+
+  // implementation of operator=() with propagate_on_container_move_assignment
+  UVector &assign_move_from(UVector<Tp, Alloc> &&other,
+                            std::true_type) noexcept {
+    deallocate();
+    Alloc::operator=(std::move(static_cast<Alloc &>(other)));
+    _begin = other._begin;
+    _end = other._end;
+    _endOfStorage = other._endOfStorage;
+    other._begin = nullptr;
+    other._end = nullptr;
+    other._endOfStorage = nullptr;
+    return *this;
+  }
+
+  // implementation of swap with propagate_on_container_swap
+  void swap(UVector<Tp, Alloc> &other, std::true_type) noexcept {
+    std::swap(_begin, other._begin);
+    std::swap(_end, other._end);
+    std::swap(_endOfStorage, other._endOfStorage);
+    std::swap(static_cast<Alloc &>(other), static_cast<Alloc &>(*this));
+  }
+
+  // implementation of swap without propagate_on_container_swap
+  void swap(UVector<Tp, Alloc> &other, std::false_type) noexcept {
+    std::swap(_begin, other._begin);
+    std::swap(_end, other._end);
+    std::swap(_endOfStorage, other._endOfStorage);
+    /**
+     * We have two choices here:
+     * - Do not swap the allocators. For stateful allocators, we would need to
+     *   reallocate memory, and iterators would not be valid UNLESS
+     *   they were stored as indices. However, containers with stateful
+     * allocators are not allowed to be swapped unless the allocators are equal,
+     * in which case swapping is not necessary.
+     * - Swap the allocators. This would not reallocate memory and
+     *   iterators remain valid, but the trait ignores
+     * propagate_on_container_swap.
+     *
+     * The standard says:
+     * "Allocator replacement is performed by copy assignment, move assignment,
+     * or swapping of the allocator only if allocator_traits<allocatortype>::
+     * propagate_on_container_copy_assignment::value,
+     * allocator_traits<allocatortype>::propagate_on_container_move_assignment::value,
+     * or allocator_traits<allocatortype>::propagate_on_container_swap::value is
+     * true within the implementation of the corresponding container operation.
+     * The behavior of a call to a container’s swap function is undefined unless
+     * the objects being swapped have allocators that compare equal or
+     * allocator_traits<allocatortype>::propagate_on_container_swap::value is
+     * true."
+     */
+  }
+
+  template <typename InputIterator>
+  void push_back_range(InputIterator first, InputIterator last,
+                       std::false_type) {
+    push_back_range<InputIterator>(
+        first, last,
+        typename std::iterator_traits<InputIterator>::iterator_category());
+  }
+
+  // This function is called from push_back(iter,iter) when Tp is an integral.
+  // In that case, the user tried to call push_back(n, &val), but it got caught
+  // by the wrong overload.
+  template <typename Integral>
+  void push_back_range(Integral n, Integral val, std::true_type) {
+    if (capacity() - size() < size_t(n)) {
+      enlarge(enlarge_size(n));
+    }
+    std::uninitialized_fill_n<Tp *, size_t>(_end, n, val);
+    _end += n;
+  }
+
+  template <typename InputIterator>
+  void push_back_range(InputIterator first, InputIterator last,
+                       std::forward_iterator_tag) {
+    size_t n = std::distance(first, last);
+    if (n > capacity() - size()) {
+      enlarge(enlarge_size(n));
+    }
+    while (first != last) {
+      *_end = *first;
+      ++_end;
+      ++first;
+    }
+  }
+};
+
+/** @brief Compare two UVectors for equality. */
+template <class Tp, class Alloc>
+inline bool operator==(const UVector<Tp, Alloc> &lhs,
+                       const UVector<Tp, Alloc> &rhs) noexcept {
+  return lhs.size() == rhs.size() &&
+         std::equal(lhs.begin(), lhs.end(), rhs.begin());
+}
+
+/** @brief Compare two UVectors for inequality. */
+template <class Tp, class Alloc>
+inline bool operator!=(const UVector<Tp, Alloc> &lhs,
+                       const UVector<Tp, Alloc> &rhs) noexcept {
+  return !(lhs == rhs);
+}
+
+/** @brief Compare two UVectors for smaller than.
+ * @details If two UVectors compare equal up to the length of one, the UVector
+ * with the smallest size is consider to be smaller.
+ */
+template <class Tp, class Alloc>
+inline bool operator<(const UVector<Tp, Alloc> &lhs,
+                      const UVector<Tp, Alloc> &rhs) noexcept {
+  const size_t minSize = std::min(lhs.size(), rhs.size());
+  for (size_t i = 0; i != minSize; ++i) {
+    if (lhs[i] < rhs[i])
+      return true;
+    else if (lhs[i] > rhs[i])
+      return false;
+  }
+  return lhs.size() < rhs.size();
+}
+
+/** @brief Compare two UVectors for smaller than or equal.
+ * @details If two UVectors compare equal up to the length of one, the UVector
+ * with the smallest size is consider to be smaller.
+ */
+template <class Tp, class Alloc>
+inline bool operator<=(const UVector<Tp, Alloc> &lhs,
+                       const UVector<Tp, Alloc> &rhs) noexcept {
+  const size_t minSize = std::min(lhs.size(), rhs.size());
+  for (size_t i = 0; i != minSize; ++i) {
+    if (lhs[i] < rhs[i])
+      return true;
+    else if (lhs[i] > rhs[i])
+      return false;
+  }
+  return lhs.size() <= rhs.size();
+}
+
+/** @brief Compare two UVectors for larger than.
+ * @details If two UVectors compare equal up to the length of one, the UVector
+ * with the smallest size is consider to be smaller.
+ */
+template <class Tp, class Alloc>
+inline bool operator>(const UVector<Tp, Alloc> &lhs,
+                      const UVector<Tp, Alloc> &rhs) noexcept {
+  return rhs < lhs;
+}
+
+/** @brief Compare two UVectors for larger than or equal.
+ * @details If two UVectors compare equal up to the length of one, the UVector
+ * with the smallest size is consider to be smaller.
+ */
+template <class Tp, class Alloc>
+inline bool operator>=(const UVector<Tp, Alloc> &lhs,
+                       const UVector<Tp, Alloc> &rhs) noexcept {
+  return rhs <= lhs;
+}
+
+/** @brief Swap the contents of the two UVectors.
+ * @details Iterators to both vectors will remain valid and will point into
+ * to the swapped container afterwards. This function will never reallocate
+ * space.
+ *
+ * The allocator will be swapped when the @c propagate_on_container_swap
+ * of the respective @c allocator_trait is @c true_type.
+ * Its behaviour is undefined when the allocators do not compare equal and
+ * @c propagate_on_container_swap is false.
+ */
+template <class Tp, class Alloc>
+inline void swap(UVector<Tp, Alloc> &x, UVector<Tp, Alloc> &y) {
+  x.swap(y);
+}
+
+/** @} */
+
+}  // namespace aocommon
+
+#endif  // AO_UVECTOR_11_H
--- /dev/null
+++ everybeam-0.1.2/external/aocommon/include/aocommon/windowfunction.h
@@ -0,0 +1,98 @@
+#ifndef AO_WINDOW_FUNCTION_H
+#define AO_WINDOW_FUNCTION_H
+
+#include <cmath>
+#include <stdexcept>
+#include <string>
+
+namespace aocommon {
+/**
+ * @brief Collection of common signal windowing functions.
+ *
+ */
+class WindowFunction {
+ public:
+  enum Type {
+    Rectangular,
+    BlackmanNutall,
+    BlackmanHarris,
+    Hann,
+    RaisedHann,
+    Tukey,
+    Gaussian
+  };
+
+  static Type GetType(const std::string& typeStr) {
+    if (typeStr == "hann") return Hann;
+    if (typeStr == "raised-hann")
+      return RaisedHann;
+    else if (typeStr == "blackman-nutall")
+      return BlackmanNutall;
+    else if (typeStr == "gaussian")
+      return Gaussian;
+    else if (typeStr == "blackman-harris")
+      return BlackmanHarris;
+    else if (typeStr == "rectangular")
+      return Rectangular;
+    else if (typeStr == "tukey")
+      return Tukey;
+    else
+      throw std::runtime_error(
+          "The window function name is not a valid. Valid windows are: "
+          "rectangular, hann, blackman-harris or blackman-nutall");
+  }
+
+  static double Evaluate(Type windowFunc, size_t n, size_t i) {
+    switch (windowFunc) {
+      case Rectangular:
+        return 1.0;
+      case BlackmanNutall:
+        return EvaluateBlackmanNutall(n, i);
+      case BlackmanHarris:
+        return EvaluateBlackmanHarris(n, i);
+      case Tukey:
+        throw std::runtime_error("Tukey window requires parameter");
+      case Hann:
+        return EvaluateHann(n, i);
+      case RaisedHann:
+        return EvaluateRaisedHann(n, i);
+      case Gaussian:
+        return EvaluateGaussian(n, i);
+    }
+    return 0.0;
+  }
+
+  static double EvaluateBlackmanNutall(size_t n, size_t i) {
+    const static double a0 = 0.3635819, a1 = 0.4891775, a2 = 0.1365995,
+                        a3 = 0.0106411;
+    const double id = double(i) * 2.0 * M_PI, nd = int(n);
+    return a0 - a1 * std::cos((id) / nd) + a2 * std::cos((2.0 * id) / nd) -
+           a3 * std::cos((3.0 * id) / nd);
+  }
+
+  static double EvaluateBlackmanHarris(size_t n, size_t i) {
+    const static double a0 = 0.35875, a1 = 0.48829, a2 = 0.14128, a3 = 0.01168;
+    const double id = double(i) * 2.0 * M_PI, nd = int(n);
+    return a0 - a1 * std::cos((id) / nd) + a2 * std::cos((2.0 * id) / nd) -
+           a3 * std::cos((3.0 * id) / nd);
+  }
+
+  static double EvaluateHann(size_t n, size_t i) {
+    double s = std::sin(M_PI * double(i) / (double(n)));
+    return s * s;
+  }
+
+  static double EvaluateRaisedHann(size_t n, size_t i) {
+    double s = std::sin(M_PI * double(i) / (double(n)));
+    return s * s * 0.99 + 1e-2;
+  }
+
+  static double EvaluateGaussian(size_t n, size_t i) {
+    /// e^(-x^2 / 2sigma^2), sigma = 1/5.
+    constexpr double oneOverSigma = 5.0;
+    double x = (double(i) / double(n) - 0.5) * oneOverSigma;
+    return std::exp(-x * x * 0.5);
+  }
+};
+}  // namespace aocommon
+#endif  // AO_WINDOW_FUNCTION_H
